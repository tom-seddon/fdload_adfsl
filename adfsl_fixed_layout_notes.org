#+STARTUP: overview

* dir-locals

#+begin_src elisp
  ((nil . ((compile-command . "cd ~/github/adfsl_fixed_layout && make _tom"))))
#+end_src

* ADFS Stuff

https://mdfs.net/Docs/Comp/Disk/Format/ADFS

For ADFS L:

2*80*16=2560 sectors on disk

-2 for fixed metadata overhead=2558 sectors

-5 for root directory=2553 sectors

2553*256=653568 bytes

* Addressing

The disk has 2 sides, one per head, H0 and H1. Each side has 80
tracks, T0-T79, and each track has 16 sectors, S0-S15.

The disk has 160 logical tracks, L0-L159, arranged physically in head
then track order (so indeed the other way round from how ADFS logical
sectoring works). So L0 is T0 H0, L1 is T0 H1, L2 is T1 H0 - and so
on.

Obviously the track is then an 8-bit value. Shift left 1 to find the
physical track number for FDC purposes.

** TOC table

Maximum likely read is $d2 sectors, i.e., filling all of RAM from
$0e00 to $dfff. 

Each item has a start logical track (8 bits, 0-159), a start sector,
(4 bits, 0-15), and a byte count (16 bits).

Reading proceeds as a sequence of multi-sector reads. Seek to physical
track, select side, do multi-read from start sector, with byte count
suitable for that track's portion of the read. NMI routine bumps byte
counter as it goes, and cancels the command once done.

If track done with still more to do, bump logical track and set sector
to 0 and go again.

* code...

#+begin_src 6502-asm
  nmi:
                  sta relda+1
                  lda fdc_data
  dest=*+1
                  sta (zdest)
                  inc zdest+0
                  bne +
                  inc zdest+1
  +
                  inc znleft+0
                  bne +
                  inc znleft+1
                  beq cancel
  +
  done:
  relda:
                  lda #$ff
                  rti

  cancel:
                  
#+end_src

* !BOOT encoding

| Case    | bol                     | !str                    | str                      |
|---------+-------------------------+-------------------------+--------------------------|
| <ch>    | 11 - :$&XXXX="<ch>      | 2 - "<ch>               | 1 - <ch>                 |
| CHR$&xx | 15 - :$&XXXX=CHR$&xx    | 9 - +CHR$&xx            | 9 - "+CHR$&xx            |
| "       | 12 - :$&XXXX="""        | 3 - """                 | 2 - ""                   |
| \!      | 18 - :\!&XXXX=&12345678 | 17 - :\!&XXXX=&12345678 | 18 - ":\!&XXXX=&12345678 |


* zx02 decompression

: ; De-compressor for ZX02 files
: ; ----------------------------
: ;
: ; Decompress ZX02 data (6502 optimized format), optimized for speed
: ;  166 bytes code, 48.0 cycles/byte in test file.
: ;
: ; Compress with:
: ;    zx02 input.bin output.zx0
: ;
: ; (c) 2022-2025 DMSC
: ; (c) 2025 Colin Leroy-Mira
: ; Code under MIT license, see LICENSE file.
: 
: 
: ZP=$80
: 
: offset_hi       equ ZP+0
: ZX0_src         equ ZP+1
: ZX0_dst         equ ZP+3
: bitr            equ ZP+5
: pntr            equ ZP+6
: 
:             ; Initial values for the de-compressor, the values are copied to
:             ; the ZP locations at the initialization:
: zx0_ini_block
:             .by $00     ; Hi byte of the initial offset-1.
:             .by <comp_data, >comp_data  ; Address of data to decompress.
:             .by <out_addr, >out_addr    ; Address to place decompressed data
:             .by $80     ; Initial value for the bit reservoir. Don't ever change.
:             .by $ff     ; Low byte of the initial offset - 1 EOR 255.  The value
:                         ; $FF means an initial offset of 1 byte, this is the
:                         ; default value. See README for the explanation of the
:                         ; '-o' option.
: 
: ;--------------------------------------------------
: ; Decompress ZX0 data (6502 optimized format)
: ;
: ; Reads data from 'comp_data' and writes the result to 'out_addr', until the
: ; compressed data ends.
: 
: full_decomp

Copy init block into the ZP working area.

:               ; Get initialization block
:               ldy #7
: 
: copy_init     ldx zx0_ini_block-1, y
:               stx offset_hi-1, y
:               dey
:               bne copy_init

always taken. X=MSB of ((initial offset)-1).

:               beq decode_literal
: 
: cop0_inc_high
:               inc   ZX0_src+1
:               inc   ZX0_dst+1
:               dex
:               bne   cop0
:               beq   cop0_done
: 
: ; Decode literal: Copy next N bytes from compressed file
: ;    Elias(length)  byte[1]  byte[2]  ...  byte[N]
: decode_literal
:               inx
:               jsr   get_elias

Copy X bytes. X bytes are consumed from the compressed data.

: 
: cop0          lda   (ZX0_src),y
:               sta   (ZX0_dst),y
:               iny
:               beq   cop0_inc_high
:               dex
:               bne   cop0
: cop0_done

Advance pointers as per copy length. It was a literal copy, so same
amount needs adding to both.

:               ; Update pointers from Y
:               tya
:               clc
:               adc   ZX0_src
:               sta   ZX0_src
:               bcc   @+
:               inc   ZX0_src+1
:               clc
: 
: @             tya
:               adc   ZX0_dst
:               sta   ZX0_dst
:               bcc   @+
:               inc   ZX0_dst+1
: @             ; Set Y back to expected
:               ldy   #$00
: 

??? - will the reservoir definitely have a valid bit here? Presumably
the encoder can arrange for that though?

:               asl   bitr
:               bcs   dzx0s_new_offset
: 
: ; Copy from last offset (repeat N bytes from last offset)
: ;    Elias(length)

Fetch encoded length in X.

:               inx
:               jsr   get_elias



: dzx0s_copy
:               lda   ZX0_dst+1
:               sbc   offset_hi  ; C=0 from get_elias
:               sta   pntr+1
: 



: cop1
:               ldy   ZX0_dst    ; Align dest pointer
:               lda   #0
:               sta   ZX0_dst
: cop1_cont
:               lda   (pntr), y
:               sta   (ZX0_dst),y
:               iny
:               beq   cop1_inc_high
:               dex
:               bne   cop1_cont
: cop1_done
:               sty   ZX0_dst    ; Update dest pointer
:               ldy   #0
:               asl   bitr
:               bcc   decode_literal
: 
: ; Copy from new offset (repeat N bytes from new offset)
: ;    Elias(MSB(offset))  LSB(offset)  Elias(length-1)
: dzx0s_new_offset
:               ; Read elias code for high part of offset
:               inx
:               jsr   get_elias
:               beq   exit  ; Read a 0, signals the end
:               ; Decrease and divide by 2
:               dex
:               txa
:               lsr   @
:               sta   offset_hi
: 
:               ; Get low part of offset, a literal 7 bits
:               lda   (ZX0_src), y
:               inc   ZX0_src
:               bne   @+
:               inc   ZX0_src+1
: @
:               ; Divide by 2
:               ror   @
:               eor   #$ff
:               sta   pntr
: 
:               ; And get the copy length.
:               ; Start elias reading with the bit already in carry:
:               ldx   #1
:               jsr   elias_skip1
: 
:               inx
:               bcc   dzx0s_copy
: 
: ; Read an elias-gamma interlaced code.
: ; ------------------------------------

https://en.wikipedia.org/wiki/Elias_gamma_coding

But the unary part and the data are interleaved. No need to maintain a
count. 



: elias_get     ; Read next data bit to result

bitr starts at $80.

:               asl   bitr

Shift bit into working value.

:               rol   @
:               tax
: 
: get_elias
:               ; Get one bit

bitr always a dummy bit set. If it ever becomes 0, all bits have been
shifted out. The bit read was the dummy bit, so it should be ignored.

:               asl   bitr

Taken if C is a valid shifted-out bit.

:               bne   elias_skip1

: 
:               ; Read new bit from stream
:               lda   (ZX0_src), y
:               inc   ZX0_src
:               bne   @+
:               inc   ZX0_src+1
: @             ;sec   ; not needed, C=1 guaranteed from last bit

Pull out the next bit, shift in the dummy bit, update the bit
reservoir. So the value ends up like this.

:   7   6   5   4   3   2   1   0      C
: +---+---+---+---+---+---+---+---+  +---+
: |D6 |D5 |D4 |D3 |D2 |D1 |D0 | 1 |  |D7 |
: +---+---+---+---+---+---+---+---+  +---+

:               rol   @
:               sta   bitr
: 
: elias_skip1

A=working value. If entered here, X is the working value.

:               txa

If a 1 bit was read, put 1 more bit into the working value.

:               bcs   elias_get

If a 0 bit was read, the number has been read. (The code is inverted
compared to the wikipedia page.)


:               ; Got ending bit, stop reading
: exit
:               rts
: 
: cop1_inc_high
:               inc   ZX0_dst+1
:               inc   pntr+1
:               dex
:               bne   cop1_cont
:               beq   cop1_done
: 

* timings

Approx bytes/sec for reading each track of the disk in turn.

| what                      | 6 ms | 12 ms |
|---------------------------+------+-------|
| for each side, each track | 9139 |  9000 |
| for each track, each side | 9677 |  9666 |

* read sizes

| Start | # bytes | # bytes | -# bytes |
|-------+---------+---------+----------|
|     0 | $1000   |    4096 | $f000    |
|     1 | $0f00   |    3840 | $f100    |
|     2 | $0e00   |    3584 | $f200    |
|     3 | $0d00   |    3328 | $f300    |
|     4 | $0c00   |    3072 | $f400    |
|     5 | $0b00   |    2816 | $f500    |
|     6 | $0a00   |    2560 | $f600    |
|     7 | $0900   |    2304 | $f700    |
|     8 | $0800   |    2048 | $f800    |
|     9 | $0700   |    1792 | $f900    |
|    10 | $0600   |    1536 | $fa00    |
|    11 | $0500   |    1280 | $fb00    |
|    12 | $0400   |    1024 | $fc00    |
|    13 | $0300   |     768 | $fd00    |
|    14 | $0200   |     512 | $fe00    |
|    15 | $0100   |     256 | $ff00    |

* NMI timing

N = normal case: no cancel, possibly both LSBs carrying.

F = final case: needs cancel

| Addr | Bytes    | Instr     | #N | TotN | #F | TotF | Label                  | Code                                       |
|------+----------+-----------+----+------+----+------+------------------------+--------------------------------------------|
| 0d00 | 8d 2a 0d | sta $0d2a |  4 |    4 |  4 |    4 |                        | sta relda+1   ; operand for STA absolute   |
| 0d03 |          |           |    |      |    |      | branch:                |                                            |
| 0d03 | 89 1d    | bit #$1d  |  2 |    6 |  2 |    6 |                        | bra command_completed                      |
| 0d05 | ad 28 fe | lda $fe28 |  6 |   12 |  6 |   12 |                        | lda fdc.status                             |
| 0d08 | 89 1c    | bit #$1c  |  2 |   14 |  2 |   14 |                        | bit #%00011100  ; RnF/CRC/Lost Data errors |
| 0d0a | d0 13    | bne $0d1f |  2 |   16 |  2 |   16 |                        | bne cancel_command ;                       |
| 0d0c | ad 2b fe | lda $fe2b |  6 |   22 |  6 |   22 |                        | lda fdc.data                               |
| 0d0f | 92 81    | sta ($81) |  5 |   27 |  5 |   27 |                        | sta (read_byte_addr)                       |
| 0d11 | e6 81    | inc $81   |  5 |   32 |  5 |   32 |                        | inc read_byte_addr+0                       |
| 0d13 | d0 02    | bne $0d17 |  2 |   34 |  2 |   34 |                        | bne got_read_byte_addr                     |
| 0d15 | e6 82    | inc $82   |  5 |   39 |  5 |   39 |                        | inc read_byte_addr+1                       |
| 0d17 |          |           |    |      |    |      | got_read_byte_addr:    |                                            |
| 0d17 | e6 83    | inc $83   |  5 |   44 |  5 |   44 |                        | inc read_byte_counter+0                    |
| 0d19 | d0 0e    | bne $0d29 |  2 |   46 |  2 |   46 |                        | bne got_read_byte_counter                  |
| 0d1b | e6 84    | inc $84   |  5 |   51 |  5 |   51 |                        | inc read_byte_counter+1                    |
| 0d1d | d0 0a    | bne $0d29 |  3 |   54 |  2 |   53 |                        | bne got_read_byte_counter                  |
| 0d1f |          |           |    |      |    |      | cancel_command:        |                                            |
| 0d1f | 20 39 28 | jsr $2839 |    |      |  6 |   59 |                        | jsr cancel                                 |
| 0d22 |          |           |    |      |    |      | command_completed:     |                                            |
| 0d22 | ad 28 fe | lda $fe28 |  6 |   60 |    |      |                        | lda fdc.status                             |
| 0d25 | 29 7f    | and #$7f  |  2 |   62 |    |      |                        | and #$7f ; indicate not busy               |
| 0d27 | 85 80    | sta $80   |  4 |   66 |    |      |                        | sta command_status                         |
| 0d29 |          |           |    |      |    |      | got_read_byte_counter: |                                            |
| 0d29 |          |           |    |      |    |      | nmi_done:              |                                            |
| 0d29 | a9 ff    | lda #$ff  |  2 |   56 |    |      | relda:                 | lda #$ff                                   |
| 0d2b | 40       | rti       |  7 |   63 |    |      | rti                    |                                            |

* eof
