#+STARTUP: overview

* General notes

(somewhere probably better for this...)

** Goals

The idea is to produce an ADFS L disk, with 1 file on it, 653,568
bytes, occupying every sector. This means that it has to start at head
0 track 0 sector 7 (the first free sector on the disk) - there are no
other options - and accessing the contents via the FDC directly would
be easy.

Call this file =!BOOT=, and make the boot option 3 (EXEC), and the BBC
could actually boot it: have the file load some code somehow, then set
it running, then do the close EXEC/SPOOL files OSBYTE. Just a question
of some details, which boot_builder is intended to help look after.

boot_builder does multiple things:

1. handle the list of files that are to go on the disk
2. compress any files that need compressing
3. sort out loader0, the initial loader. (This needs encoding to
   create a boot file pokes this into memory with a sequence of `!`
   operator statements, then a `CALL` to set it going.) loader0's size
   is limited and boot_builder will barf if it's too large
4. sort out loader1, the secondary loader. This starts at ADFS sector
   1280 (H0 T0 S0) and can occupy max 4096 bytes/1 track in total,
   including the binary TOC that gets appended to it
5. append the files from steps 1 and 2 to the disk in the proper order

The assumption is that the disk will ultimately be read in track then
head order, meaning (say) H0 T1 S15 is followed by H1 T1 S0 - then so
on until H1 T1 S15, which will be followed by H0 T2 S0. (More
heads'-worth of data per seek!)

ADFS works differently, going trackwise first then headwise. The
limited sizes of loader0 and loader1 are there to deal with this.

H0 T0 is partly booked for unavoidable ADFS metadata: disk free space
table (2 sectors), and root directory (5 sectors). The remaining 9
sectors is available for loader0's encoded form.

H1 T0 is booked for loader1. 

H0 T1 is where the data for additional files starts. Total amount
available is 2 heads * 79 tracks * 16 sectors * 256 bytes = 647,168
bytes.

** Build stages

boot_builder runs in multiple stages to produce a given disk. For all
stages, supply the same command line arguments:

- =--list= :: the Python list file, a file with Python code in it that
  specifies the files to include on the disk in the order they should
  be included. **Must be idempotent** - it'll be re-evaluated for each
  stage. Don't scrape the disk to get the file names or anything like
  that...
- =--intermediate-folder= :: folder to store intermediate stuff in:
  boot file contents, info about the TOC, plus maybe other stuff
- =--zx02pack-zx02= :: path to the zx02 binary
- =--zx02pack-cache= :: path to the zx02pack cache, a folder/file
  hierarchy indexed by SHA256 of the uncompressed data. This is used
  to quickly retrieve (or, less quickly, produce on demand) the zx02
  compressed form of any data

Stages are as follows. Use =--help= for more info, and/or examine the
makefile.

- =prepare= :: create any required folders, and produce an asm include
  file with constants for each file on the disk
- =build= :: create the boot file. Provide paths to loader0 and
  loader1 (as above), producing a boot file suitable for writing to an
  ADFS L disk somehow
- =beeblink= :: fill a BeebLink DFS-type folder with all the files
  that went on the disk, for possible use with =FDLOAD5=

** Test programs

Not productized. Might not work if you're not me.

- =:Z.$.FDLOAD= :: test version of the disk loader, assembled to run
  from $2800, TOC appended, with some entry points at
  the start
- =FDLOAD5= :: load files from disk in turn, load corresponding file
  from =boot_builder beeblink=, compare
- =ZX0LOAD3= :: load specific compressed file from disk and unpack it

* dir-locals

#+begin_src elisp
  ((nil . ((compile-command . "cd ~/github/adfsl_fixed_layout && make _tom"))))
#+end_src

* ADFS Stuff

https://mdfs.net/Docs/Comp/Disk/Format/ADFS

For ADFS L:

2*80*16=2560 sectors on disk

-2 for fixed metadata overhead=2558 sectors

-5 for root directory=2553 sectors

2553*256=653568 bytes

* Addressing

The disk has 2 sides, one per head, H0 and H1. Each side has 80
tracks, T0-T79, and each track has 16 sectors, S0-S15.

The disk has 160 logical tracks, L0-L159, arranged physically in head
then track order (so indeed the other way round from how ADFS logical
sectoring works). So L0 is T0 H0, L1 is T0 H1, L2 is T1 H0 - and so
on.

Obviously the track is then an 8-bit value. Shift left 1 to find the
physical track number for FDC purposes.

** TOC table

Maximum likely read is $d2 sectors, i.e., filling all of RAM from
$0e00 to $dfff. 

Each item has a start logical track (8 bits, 0-159), a start sector,
(4 bits, 0-15), and a byte count (16 bits).

Reading proceeds as a sequence of multi-sector reads. Seek to physical
track, select side, do multi-read from start sector, with byte count
suitable for that track's portion of the read. NMI routine bumps byte
counter as it goes, and cancels the command once done.

If track done with still more to do, bump logical track and set sector
to 0 and go again.

* code...

#+begin_src 6502-asm
  nmi:
                  sta relda+1
                  lda fdc_data
  dest=*+1
                  sta (zdest)
                  inc zdest+0
                  bne +
                  inc zdest+1
  +
                  inc znleft+0
                  bne +
                  inc znleft+1
                  beq cancel
  +
  done:
  relda:
                  lda #$ff
                  rti

  cancel:
                  
#+end_src

* !BOOT encoding

| Case    | bol                     | !str                    | str                      |
|---------+-------------------------+-------------------------+--------------------------|
| <ch>    | 11 - :$&XXXX="<ch>      | 2 - "<ch>               | 1 - <ch>                 |
| CHR$&xx | 15 - :$&XXXX=CHR$&xx    | 9 - +CHR$&xx            | 9 - "+CHR$&xx            |
| "       | 12 - :$&XXXX="""        | 3 - """                 | 2 - ""                   |
| \!      | 18 - :\!&XXXX=&12345678 | 17 - :\!&XXXX=&12345678 | 18 - ":\!&XXXX=&12345678 |


* zx02 decompression

: ; De-compressor for ZX02 files
: ; ----------------------------
: ;
: ; Decompress ZX02 data (6502 optimized format), optimized for speed
: ;  166 bytes code, 48.0 cycles/byte in test file.
: ;
: ; Compress with:
: ;    zx02 input.bin output.zx0
: ;
: ; (c) 2022-2025 DMSC
: ; (c) 2025 Colin Leroy-Mira
: ; Code under MIT license, see LICENSE file.
: 
: 
: ZP=$80
: 
: offset_hi       equ ZP+0
: ZX0_src         equ ZP+1
: ZX0_dst         equ ZP+3
: bitr            equ ZP+5
: pntr            equ ZP+6
: 
:             ; Initial values for the de-compressor, the values are copied to
:             ; the ZP locations at the initialization:
: zx0_ini_block
:             .by $00     ; Hi byte of the initial offset-1.
:             .by <comp_data, >comp_data  ; Address of data to decompress.
:             .by <out_addr, >out_addr    ; Address to place decompressed data
:             .by $80     ; Initial value for the bit reservoir. Don't ever change.
:             .by $ff     ; Low byte of the initial offset - 1 EOR 255.  The value
:                         ; $FF means an initial offset of 1 byte, this is the
:                         ; default value. See README for the explanation of the
:                         ; '-o' option.
: 
: ;--------------------------------------------------
: ; Decompress ZX0 data (6502 optimized format)
: ;
: ; Reads data from 'comp_data' and writes the result to 'out_addr', until the
: ; compressed data ends.
: 
: full_decomp

Copy init block into the ZP working area.

:               ; Get initialization block
:               ldy #7
: 
: copy_init     ldx zx0_ini_block-1, y
:               stx offset_hi-1, y
:               dey
:               bne copy_init

always taken. X=MSB of ((initial offset)-1).

:               beq decode_literal
: 
: cop0_inc_high
:               inc   ZX0_src+1
:               inc   ZX0_dst+1
:               dex
:               bne   cop0
:               beq   cop0_done
: 
: ; Decode literal: Copy next N bytes from compressed file
: ;    Elias(length)  byte[1]  byte[2]  ...  byte[N]
: decode_literal
:               inx
:               jsr   get_elias

Copy X bytes. X bytes are consumed from the compressed data.

: 
: cop0          lda   (ZX0_src),y
:               sta   (ZX0_dst),y
:               iny
:               beq   cop0_inc_high
:               dex
:               bne   cop0
: cop0_done

Advance pointers as per copy length. It was a literal copy, so same
amount needs adding to both.

:               ; Update pointers from Y
:               tya
:               clc
:               adc   ZX0_src
:               sta   ZX0_src
:               bcc   @+
:               inc   ZX0_src+1
:               clc
: 
: @             tya
:               adc   ZX0_dst
:               sta   ZX0_dst
:               bcc   @+
:               inc   ZX0_dst+1
: @             ; Set Y back to expected
:               ldy   #$00
: 

??? - will the reservoir definitely have a valid bit here? Presumably
the encoder can arrange for that though?

:               asl   bitr
:               bcs   dzx0s_new_offset
: 
: ; Copy from last offset (repeat N bytes from last offset)
: ;    Elias(length)

Fetch encoded length in X.

:               inx
:               jsr   get_elias



: dzx0s_copy
:               lda   ZX0_dst+1
:               sbc   offset_hi  ; C=0 from get_elias
:               sta   pntr+1
: 



: cop1
:               ldy   ZX0_dst    ; Align dest pointer
:               lda   #0
:               sta   ZX0_dst
: cop1_cont
:               lda   (pntr), y
:               sta   (ZX0_dst),y
:               iny
:               beq   cop1_inc_high
:               dex
:               bne   cop1_cont
: cop1_done
:               sty   ZX0_dst    ; Update dest pointer
:               ldy   #0
:               asl   bitr
:               bcc   decode_literal
: 
: ; Copy from new offset (repeat N bytes from new offset)
: ;    Elias(MSB(offset))  LSB(offset)  Elias(length-1)
: dzx0s_new_offset
:               ; Read elias code for high part of offset
:               inx
:               jsr   get_elias
:               beq   exit  ; Read a 0, signals the end
:               ; Decrease and divide by 2
:               dex
:               txa
:               lsr   @
:               sta   offset_hi
: 
:               ; Get low part of offset, a literal 7 bits
:               lda   (ZX0_src), y
:               inc   ZX0_src
:               bne   @+
:               inc   ZX0_src+1
: @
:               ; Divide by 2
:               ror   @
:               eor   #$ff
:               sta   pntr
: 
:               ; And get the copy length.
:               ; Start elias reading with the bit already in carry:
:               ldx   #1
:               jsr   elias_skip1
: 
:               inx
:               bcc   dzx0s_copy
: 
: ; Read an elias-gamma interlaced code.
: ; ------------------------------------

https://en.wikipedia.org/wiki/Elias_gamma_coding

But the unary part and the data are interleaved. No need to maintain a
count. 



: elias_get     ; Read next data bit to result

bitr starts at $80.

:               asl   bitr

Shift bit into working value.

:               rol   @
:               tax
: 
: get_elias
:               ; Get one bit

bitr always a dummy bit set. If it ever becomes 0, all bits have been
shifted out. The bit read was the dummy bit, so it should be ignored.

:               asl   bitr

Taken if C is a valid shifted-out bit.

:               bne   elias_skip1

: 
:               ; Read new bit from stream
:               lda   (ZX0_src), y
:               inc   ZX0_src
:               bne   @+
:               inc   ZX0_src+1
: @             ;sec   ; not needed, C=1 guaranteed from last bit

Pull out the next bit, shift in the dummy bit, update the bit
reservoir. So the value ends up like this.

:   7   6   5   4   3   2   1   0      C
: +---+---+---+---+---+---+---+---+  +---+
: |D6 |D5 |D4 |D3 |D2 |D1 |D0 | 1 |  |D7 |
: +---+---+---+---+---+---+---+---+  +---+

:               rol   @
:               sta   bitr
: 
: elias_skip1

A=working value. If entered here, X is the working value.

:               txa

If a 1 bit was read, put 1 more bit into the working value.

:               bcs   elias_get

If a 0 bit was read, the number has been read. (The code is inverted
compared to the wikipedia page.)


:               ; Got ending bit, stop reading
: exit
:               rts
: 
: cop1_inc_high
:               inc   ZX0_dst+1
:               inc   pntr+1
:               dex
:               bne   cop1_cont
:               beq   cop1_done
: 

* timings

Approx bytes/sec for reading each track of the disk in turn.

| what                      | 6 ms | 12 ms |
|---------------------------+------+-------|
| for each side, each track | 9139 |  9000 |
| for each track, each side | 9677 |  9666 |

* read sizes

| Start | # bytes | # bytes | -# bytes |
|-------+---------+---------+----------|
|     0 | $1000   |    4096 | $f000    |
|     1 | $0f00   |    3840 | $f100    |
|     2 | $0e00   |    3584 | $f200    |
|     3 | $0d00   |    3328 | $f300    |
|     4 | $0c00   |    3072 | $f400    |
|     5 | $0b00   |    2816 | $f500    |
|     6 | $0a00   |    2560 | $f600    |
|     7 | $0900   |    2304 | $f700    |
|     8 | $0800   |    2048 | $f800    |
|     9 | $0700   |    1792 | $f900    |
|    10 | $0600   |    1536 | $fa00    |
|    11 | $0500   |    1280 | $fb00    |
|    12 | $0400   |    1024 | $fc00    |
|    13 | $0300   |     768 | $fd00    |
|    14 | $0200   |     512 | $fe00    |
|    15 | $0100   |     256 | $ff00    |

* NMI timing

N = normal case: no cancel, possibly both LSBs carrying.

F = final case: needs cancel

| Addr | Bytes    | Instr     | #N | TotN | #F | TotF | Label                  | Code                                       |
|------+----------+-----------+----+------+----+------+------------------------+--------------------------------------------|
| 0d00 | 8d 2a 0d | sta $0d2a |  4 |    4 |  4 |    4 |                        | sta relda+1   ; operand for STA absolute   |
| 0d03 |          |           |    |      |    |      | branch:                |                                            |
| 0d03 | 89 1d    | bit #$1d  |  2 |    6 |  2 |    6 |                        | bra command_completed                      |
| 0d05 | ad 28 fe | lda $fe28 |  6 |   12 |  6 |   12 |                        | lda fdc.status                             |
| 0d08 | 89 1c    | bit #$1c  |  2 |   14 |  2 |   14 |                        | bit #%00011100  ; RnF/CRC/Lost Data errors |
| 0d0a | d0 13    | bne $0d1f |  2 |   16 |  2 |   16 |                        | bne cancel_command ;                       |
| 0d0c | ad 2b fe | lda $fe2b |  6 |   22 |  6 |   22 |                        | lda fdc.data                               |
| 0d0f | 92 81    | sta ($81) |  5 |   27 |  5 |   27 |                        | sta (read_byte_addr)                       |
| 0d11 | e6 81    | inc $81   |  5 |   32 |  5 |   32 |                        | inc read_byte_addr+0                       |
| 0d13 | d0 02    | bne $0d17 |  2 |   34 |  2 |   34 |                        | bne got_read_byte_addr                     |
| 0d15 | e6 82    | inc $82   |  5 |   39 |  5 |   39 |                        | inc read_byte_addr+1                       |
| 0d17 |          |           |    |      |    |      | got_read_byte_addr:    |                                            |
| 0d17 | e6 83    | inc $83   |  5 |   44 |  5 |   44 |                        | inc read_byte_counter+0                    |
| 0d19 | d0 0e    | bne $0d29 |  2 |   46 |  2 |   46 |                        | bne got_read_byte_counter                  |
| 0d1b | e6 84    | inc $84   |  5 |   51 |  5 |   51 |                        | inc read_byte_counter+1                    |
| 0d1d | d0 0a    | bne $0d29 |  3 |   54 |  2 |   53 |                        | bne got_read_byte_counter                  |
| 0d1f |          |           |    |      |    |      | cancel_command:        |                                            |
| 0d1f | 20 39 28 | jsr $2839 |    |      |  6 |   59 |                        | jsr cancel                                 |
| 0d22 |          |           |    |      |    |      | command_completed:     |                                            |
| 0d22 | ad 28 fe | lda $fe28 |  6 |   60 |    |      |                        | lda fdc.status                             |
| 0d25 | 29 7f    | and #$7f  |  2 |   62 |    |      |                        | and #$7f ; indicate not busy               |
| 0d27 | 85 80    | sta $80   |  4 |   66 |    |      |                        | sta command_status                         |
| 0d29 |          |           |    |      |    |      | got_read_byte_counter: |                                            |
| 0d29 |          |           |    |      |    |      | nmi_done:              |                                            |
| 0d29 | a9 ff    | lda #$ff  |  2 |   56 |    |      | relda:                 | lda #$ff                                   |
| 0d2b | 40       | rti       |  7 |   63 |    |      | rti                    |                                            |

* ZX0LOAD1 timings

initial: T=6.87; S=3906/s; D=29810/s

tweaked: T=4.59; S=5846/s; D=44618/s

* eof
