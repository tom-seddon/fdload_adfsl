#+STARTUP: overview

* General notes

(somewhere probably better for this...)

Disk location syntax is =Hh Tt Ss= - where =h= is the head/side (0/1),
=t= the track (0-79) and =s= the sector (0-15).

** Goals

The idea is to produce an ADFS L disk, with 1 file on it, 653,568
bytes, occupying every sector. This means that it has to start at head
0 track 0 sector 7 (the first free sector on the disk) - there are no
other options - and accessing the contents via the FDC directly would
be easy.

Call this file =!BOOT=, and make the boot option 3 (EXEC), and the BBC
could actually boot it: have the file load some code somehow, then set
it running, then do the close EXEC/SPOOL files OSBYTE. Just a question
of some details.

** =boot_builder=

boot_builder looks after the details. 

1. handle the list of files that are to go on the disk
2. compress any files that need compressing
3. sort out loader0, the initial loader: create a *EXECable !BOOT file
   that pokes it into memory with a sequence of =!= operator
   statements, then does a =CALL= to set it going.

   The =!= syntax is not very space efficient, so loader0's size is
   limited to 512 bytes.
4. sort out loader1, the secondary loader: this goes on the disk
   as-is, but at a specific position so that loader0 can load it.

   loader1's size is max 4096 bytes/1 track.
5. arrange the files from steps 1 and 2 in the =!BOOT= file as required

The assumption is that the disk will ultimately be read in track then
head order, meaning (say) H0 T1 S15 is followed by H1 T1 S0 - then so
on until H1 T1 S15, which will be followed by H0 T2 S0. (More
heads'-worth of data per seek!) So the =!BOOT= file is arranged with
that in mind.

** Eventual disk layout

H0 T0 is partly booked for unavoidable ADFS metadata: disk free space
table (2 sectors), and root directory (5 sectors). The remaining 9
sectors is available for loader0's encoded form.

H1 T0 is booked for loader1. 

H0 T1 is where the data for additional files starts. Total amount
available is 2 heads * 79 tracks * 16 sectors * 256 bytes = 647,168
bytes.

The ADFS disk layout is head then track, so (say) H0 T0 S15 is
followed by H0 T1 S0, and so on - then H0 T79 S15 is followed by H1 T0
S0. The only bit of data that's sensible readable by ADFS is the *EXEC
prefix.

** loaders

loader0 is intended to be fairly generic. It ensures no Tube, Master
128 hardware, accessible sideways RAM, doing a BRK if required. Then
loads loader1 from its known place on disk.

loader1 can do anything required.

** Build stages

boot_builder runs in multiple stages to produce a given disk. For all
stages, supply the same command line arguments:

- =--list= :: the Python list file, a file with Python code in it that
  specifies the files to include on the disk in the order they should
  be included. **Must be idempotent** - it'll be re-evaluated for each
  stage. Don't scrape the disk to get the file names or anything like
  that...
- =--intermediate-folder= :: folder to store intermediate stuff in:
  boot file contents, info about the TOC, plus maybe other stuff
- =--zx02= :: path to the zx02 binary
- =--zx02-cache= :: path to the zx02 cache, a folder/file hierarchy
  indexed by SHA256 of the uncompressed data. This is used to quickly
  retrieve (or, less quickly, produce on demand) the zx02 compressed
  form of any data

Stages are as follows. Use =--help= for more info, and/or examine the
makefile.

- =prepare= :: create any required folders, and produce an asm include
  file with constants for each file on the disk
- =warm-zx02-cache= :: warm up the zx02 cache by compressing any files
  that can be found on disk that don't have cached compressed
  versions. The build will work without the warmup step - files will
  be compressed on demand - but the warmup step will do any
  compression in parallel to take advantage of multi-core CPUs
- =build-fdload-data= :: assemble the disk data and generate the TOC
- =build-disk-contents= :: create a folder containing the final !BOOT
  file and a .inf file for it, suitable for use with [[https://github.com/tom-seddon/beeb/tree/master/bin#adf_create][=adf_create.py=]]
- =beeblink= :: fill a BeebLink DFS-style folder with all the files
  that went on disk, for possible test purposes

** Expected process

The Makefile is intended to go roughly like this:

1. =boot_builder prepare= to generate the files list
2. generate data files or whatever
3. assemble individual bits of whatever you're doing. Include the
   files list file from step 1 to get the file indexes
4. =boot_builder warm-zx02-cache= to compress anything that needs
   doing
5. =boot_builder build-fdload-data= to build the disk data and
   generate the TOC
6. assemble loader0
7. assemble loader1, which will very likely incbin the TOC data from
   step 5
8. =boot_builder build-disk-contents=, supplying assembled loader0 and
   loader1

** fdload

Include in project's loader1. loader1 will have to do some stuff to
put the fdload code somewhere useful.

*** =.dsection fdload_zp=

This is where fdload's ZP stuff will go.

*** =.dsection fdload_init_code=

This is where fdload's init code will go: the =fdload.init= routine,
and the NMI routine bits that get copied to page 13.

*** =.dsection fdload_working_code=

This is where fdload's working code will go.

*** =fdload_banked_version=, =fdload_working_code=, =fdload_select_bank=, =fdload_restore_bank=

By default, the fdload working code runs in place.

Set =fdload_banked_version= to have fdload copy the working code to
main memory on each call to =fdload.init=.

=fdload_working_code= is the address to which =fdload.init= should
copy the working code. 

=fdload_select_bank= selects the banked region that fdload is stored
in, giving access to the fdload_init_code region. Store the previous
state - probably just ACCCON and ROMSEL - in X/Y on exit. Preserve A.

=fdload_restore_bank= restores the banked region selected by
=fdload_select_bank=. X/Y are the values from on exit from
=fdload_select_bank=. Preserve A and C.

TODO: this naming sucks.

*** =fdload_toc=

This must be the start address of the incbin'd TOC data.

*** Call =fdload.one_time_init=

This needs doing once on startup to ensure the drive is at track 0 and
the FDC state is consistent. (Shouldn't take long to run, as the ADFS
boot process should hopefully mean the drive is at track 0 already.)

This calls =fdload.init=, so the entry points are available once it's
called.

** Entry points

To prepare fdload for use, do whatever bank selection needs doing then
call =fdload.init=. Exact steps will be project-specific as it'll
depend on what loader1 does.

Entry points must be entered with =jsr=. Follow each entry point with
the arguments as bytes. For example, to load file 3's on-disk data to
$3000:

#+begin_src 6502-asm
                  jsr $d83        ; entry point
                  .word $3000     ; address to load to
                  .byte 3         ; file index
                  
                  nop             ; execution will resume here
#+end_src

(The routine will arrange for them to be skipped over when returning.)

Once done with the disk, the fdload regions can be overwritten.

*** $d80 - load file contents

Load file's contents into memory. If compressed, it will be
uncompressed. If the execute flag is set, its load address will be
jumped to once loaded (meaning the file can be loaded on top of the
caller).

| Arg | Size | What                        |
|-----+------+-----------------------------|
|  +0 | w    | address to load data to     |
|  +2 | b    | MSB of decompression buffer |
|  +3 | b    | file's index                |

The decompression buffer is 4 KB (4096 bytes) ($1000 bytes) (16
pages). These 16 pages have to be contiguous. In theory the buffer can
overlap the uncompressed data, as per zx02 docs.

The loading doesn't alter the paging settings. The right regions must
be paged in for compression buffer and destination address to make
sense.

*** $d83 - load file's on-disk data

Load file's on-disk data into memory.

| Arg | Size | What                    |
|-----+------+-------------------------|
|  +0 | w    | address to load data to |
|  +2 | b    | file's index            |

The file is read straight to the load address.

The loading doesn't alter the paging settings. The right regions must
be paged in for the address to make sense.

** Test programs

Not productized. Might not work if you're not me.

- =:Z.$.FDLOAD= :: test version of the disk loader, assembled to run
  from $2800, TOC appended, with some entry points at
  the start
- =FDLOAD5= :: load files from disk in turn, load corresponding file
  from =boot_builder beeblink=, compare
- =ZX0LOAD3= :: load specific compressed file from disk and unpack it

* dir-locals

#+begin_src elisp
  ((nil . ((compile-command . "cd ~/github/fdload_adfsl && make _tom"))))
#+end_src

* ADFS Stuff

https://mdfs.net/Docs/Comp/Disk/Format/ADFS

For ADFS L:

2*80*16=2560 sectors on disk

-2 for fixed metadata overhead=2558 sectors

-5 for root directory=2553 sectors

2553*256=653568 bytes

* Addressing

The disk has 2 sides, one per head, H0 and H1. Each side has 80
tracks, T0-T79, and each track has 16 sectors, S0-S15.

The disk has 160 logical tracks, L0-L159, arranged physically in head
then track order (so indeed the other way round from how ADFS logical
sectoring works). So L0 is T0 H0, L1 is T0 H1, L2 is T1 H0 - and so
on.

Obviously the track is then an 8-bit value. Shift left 1 to find the
physical track number for FDC purposes.

** TOC table

Maximum likely read is $d2 sectors, i.e., filling all of RAM from
$0e00 to $dfff. 

Each item has a start logical track (8 bits, 0-159), a start sector,
(4 bits, 0-15), and a byte count (16 bits).

Reading proceeds as a sequence of multi-sector reads. Seek to physical
track, select side, do multi-read from start sector, with byte count
suitable for that track's portion of the read. NMI routine bumps byte
counter as it goes, and cancels the command once done.

If track done with still more to do, bump logical track and set sector
to 0 and go again.

* code...

#+begin_src 6502-asm
  nmi:
                  sta relda+1
                  lda fdc_data
  dest=*+1
                  sta (zdest)
                  inc zdest+0
                  bne +
                  inc zdest+1
  +
                  inc znleft+0
                  bne +
                  inc znleft+1
                  beq cancel
  +
  done:
  relda:
                  lda #$ff
                  rti

  cancel:
                  
#+end_src

* !BOOT encoding

| Case    | bol                     | !str                    | str                      |
|---------+-------------------------+-------------------------+--------------------------|
| <ch>    | 11 - :$&XXXX="<ch>      | 2 - "<ch>               | 1 - <ch>                 |
| CHR$&xx | 15 - :$&XXXX=CHR$&xx    | 9 - +CHR$&xx            | 9 - "+CHR$&xx            |
| "       | 12 - :$&XXXX="""        | 3 - """                 | 2 - ""                   |
| \!      | 18 - :\!&XXXX=&12345678 | 17 - :\!&XXXX=&12345678 | 18 - ":\!&XXXX=&12345678 |


* zx02 decompression

: ; De-compressor for ZX02 files
: ; ----------------------------
: ;
: ; Decompress ZX02 data (6502 optimized format), optimized for speed
: ;  166 bytes code, 48.0 cycles/byte in test file.
: ;
: ; Compress with:
: ;    zx02 input.bin output.zx0
: ;
: ; (c) 2022-2025 DMSC
: ; (c) 2025 Colin Leroy-Mira
: ; Code under MIT license, see LICENSE file.
: 
: 
: ZP=$80
: 
: offset_hi       equ ZP+0
: ZX0_src         equ ZP+1
: ZX0_dst         equ ZP+3
: bitr            equ ZP+5
: pntr            equ ZP+6
: 
:             ; Initial values for the de-compressor, the values are copied to
:             ; the ZP locations at the initialization:
: zx0_ini_block
:             .by $00     ; Hi byte of the initial offset-1.
:             .by <comp_data, >comp_data  ; Address of data to decompress.
:             .by <out_addr, >out_addr    ; Address to place decompressed data
:             .by $80     ; Initial value for the bit reservoir. Don't ever change.
:             .by $ff     ; Low byte of the initial offset - 1 EOR 255.  The value
:                         ; $FF means an initial offset of 1 byte, this is the
:                         ; default value. See README for the explanation of the
:                         ; '-o' option.
: 
: ;--------------------------------------------------
: ; Decompress ZX0 data (6502 optimized format)
: ;
: ; Reads data from 'comp_data' and writes the result to 'out_addr', until the
: ; compressed data ends.
: 
: full_decomp

Copy init block into the ZP working area.

:               ; Get initialization block
:               ldy #7
: 
: copy_init     ldx zx0_ini_block-1, y
:               stx offset_hi-1, y
:               dey
:               bne copy_init

always taken. X=MSB of ((initial offset)-1).

:               beq decode_literal
: 
: cop0_inc_high
:               inc   ZX0_src+1
:               inc   ZX0_dst+1
:               dex
:               bne   cop0
:               beq   cop0_done
: 
: ; Decode literal: Copy next N bytes from compressed file
: ;    Elias(length)  byte[1]  byte[2]  ...  byte[N]
: decode_literal
:               inx
:               jsr   get_elias

Copy X bytes. X bytes are consumed from the compressed data.

: 
: cop0          lda   (ZX0_src),y
:               sta   (ZX0_dst),y
:               iny
:               beq   cop0_inc_high
:               dex
:               bne   cop0
: cop0_done

Advance pointers as per copy length. It was a literal copy, so same
amount needs adding to both.

:               ; Update pointers from Y
:               tya
:               clc
:               adc   ZX0_src
:               sta   ZX0_src
:               bcc   @+
:               inc   ZX0_src+1
:               clc
: 
: @             tya
:               adc   ZX0_dst
:               sta   ZX0_dst
:               bcc   @+
:               inc   ZX0_dst+1
: @             ; Set Y back to expected
:               ldy   #$00
: 

??? - will the reservoir definitely have a valid bit here? Presumably
the encoder can arrange for that though?

:               asl   bitr
:               bcs   dzx0s_new_offset
: 
: ; Copy from last offset (repeat N bytes from last offset)
: ;    Elias(length)

Fetch encoded length in X.

:               inx
:               jsr   get_elias



: dzx0s_copy
:               lda   ZX0_dst+1
:               sbc   offset_hi  ; C=0 from get_elias
:               sta   pntr+1
: 



: cop1
:               ldy   ZX0_dst    ; Align dest pointer
:               lda   #0
:               sta   ZX0_dst
: cop1_cont
:               lda   (pntr), y
:               sta   (ZX0_dst),y
:               iny
:               beq   cop1_inc_high
:               dex
:               bne   cop1_cont
: cop1_done
:               sty   ZX0_dst    ; Update dest pointer
:               ldy   #0
:               asl   bitr
:               bcc   decode_literal
: 
: ; Copy from new offset (repeat N bytes from new offset)
: ;    Elias(MSB(offset))  LSB(offset)  Elias(length-1)
: dzx0s_new_offset
:               ; Read elias code for high part of offset
:               inx
:               jsr   get_elias
:               beq   exit  ; Read a 0, signals the end
:               ; Decrease and divide by 2
:               dex
:               txa
:               lsr   @
:               sta   offset_hi
: 
:               ; Get low part of offset, a literal 7 bits
:               lda   (ZX0_src), y
:               inc   ZX0_src
:               bne   @+
:               inc   ZX0_src+1
: @
:               ; Divide by 2
:               ror   @
:               eor   #$ff
:               sta   pntr
: 
:               ; And get the copy length.
:               ; Start elias reading with the bit already in carry:
:               ldx   #1
:               jsr   elias_skip1
: 
:               inx
:               bcc   dzx0s_copy
: 
: ; Read an elias-gamma interlaced code.
: ; ------------------------------------

https://en.wikipedia.org/wiki/Elias_gamma_coding

But the unary part and the data are interleaved. No need to maintain a
count. 



: elias_get     ; Read next data bit to result

bitr starts at $80.

:               asl   bitr

Shift bit into working value.

:               rol   @
:               tax
: 
: get_elias
:               ; Get one bit

bitr always a dummy bit set. If it ever becomes 0, all bits have been
shifted out. The bit read was the dummy bit, so it should be ignored.

:               asl   bitr

Taken if C is a valid shifted-out bit.

:               bne   elias_skip1

: 
:               ; Read new bit from stream
:               lda   (ZX0_src), y
:               inc   ZX0_src
:               bne   @+
:               inc   ZX0_src+1
: @             ;sec   ; not needed, C=1 guaranteed from last bit

Pull out the next bit, shift in the dummy bit, update the bit
reservoir. So the value ends up like this.

:   7   6   5   4   3   2   1   0      C
: +---+---+---+---+---+---+---+---+  +---+
: |D6 |D5 |D4 |D3 |D2 |D1 |D0 | 1 |  |D7 |
: +---+---+---+---+---+---+---+---+  +---+

:               rol   @
:               sta   bitr
: 
: elias_skip1

A=working value. If entered here, X is the working value.

:               txa

If a 1 bit was read, put 1 more bit into the working value.

:               bcs   elias_get

If a 0 bit was read, the number has been read. (The code is inverted
compared to the wikipedia page.)


:               ; Got ending bit, stop reading
: exit
:               rts
: 
: cop1_inc_high
:               inc   ZX0_dst+1
:               inc   pntr+1
:               dex
:               bne   cop1_cont
:               beq   cop1_done
: 

* timings

Approx bytes/sec for reading each track of the disk in turn.

| what                      | 6 ms | 12 ms |
|---------------------------+------+-------|
| for each side, each track | 9139 |  9000 |
| for each track, each side | 9677 |  9666 |

* read sizes

| Start | # bytes | # bytes | -# bytes |
|-------+---------+---------+----------|
|     0 | $1000   |    4096 | $f000    |
|     1 | $0f00   |    3840 | $f100    |
|     2 | $0e00   |    3584 | $f200    |
|     3 | $0d00   |    3328 | $f300    |
|     4 | $0c00   |    3072 | $f400    |
|     5 | $0b00   |    2816 | $f500    |
|     6 | $0a00   |    2560 | $f600    |
|     7 | $0900   |    2304 | $f700    |
|     8 | $0800   |    2048 | $f800    |
|     9 | $0700   |    1792 | $f900    |
|    10 | $0600   |    1536 | $fa00    |
|    11 | $0500   |    1280 | $fb00    |
|    12 | $0400   |    1024 | $fc00    |
|    13 | $0300   |     768 | $fd00    |
|    14 | $0200   |     512 | $fe00    |
|    15 | $0100   |     256 | $ff00    |

* NMI timing

N = normal case: no cancel, possibly both LSBs carrying.

F = final case: needs cancel

| Addr | Bytes    | Instr     | #N | TotN | #F | TotF | Label                  | Code                                       |
|------+----------+-----------+----+------+----+------+------------------------+--------------------------------------------|
| 0d00 | 8d 2a 0d | sta $0d2a |  4 |    4 |  4 |    4 |                        | sta relda+1   ; operand for STA absolute   |
| 0d03 |          |           |    |      |    |      | branch:                |                                            |
| 0d03 | 89 1d    | bit #$1d  |  2 |    6 |  2 |    6 |                        | bra command_completed                      |
| 0d05 | ad 28 fe | lda $fe28 |  6 |   12 |  6 |   12 |                        | lda fdc.status                             |
| 0d08 | 89 1c    | bit #$1c  |  2 |   14 |  2 |   14 |                        | bit #%00011100  ; RnF/CRC/Lost Data errors |
| 0d0a | d0 13    | bne $0d1f |  2 |   16 |  2 |   16 |                        | bne cancel_command ;                       |
| 0d0c | ad 2b fe | lda $fe2b |  6 |   22 |  6 |   22 |                        | lda fdc.data                               |
| 0d0f | 92 81    | sta ($81) |  5 |   27 |  5 |   27 |                        | sta (read_byte_addr)                       |
| 0d11 | e6 81    | inc $81   |  5 |   32 |  5 |   32 |                        | inc read_byte_addr+0                       |
| 0d13 | d0 02    | bne $0d17 |  2 |   34 |  2 |   34 |                        | bne got_read_byte_addr                     |
| 0d15 | e6 82    | inc $82   |  5 |   39 |  5 |   39 |                        | inc read_byte_addr+1                       |
| 0d17 |          |           |    |      |    |      | got_read_byte_addr:    |                                            |
| 0d17 | e6 83    | inc $83   |  5 |   44 |  5 |   44 |                        | inc read_byte_counter+0                    |
| 0d19 | d0 0e    | bne $0d29 |  2 |   46 |  2 |   46 |                        | bne got_read_byte_counter                  |
| 0d1b | e6 84    | inc $84   |  5 |   51 |  5 |   51 |                        | inc read_byte_counter+1                    |
| 0d1d | d0 0a    | bne $0d29 |  3 |   54 |  2 |   53 |                        | bne got_read_byte_counter                  |
| 0d1f |          |           |    |      |    |      | cancel_command:        |                                            |
| 0d1f | 20 39 28 | jsr $2839 |    |      |  6 |   59 |                        | jsr cancel                                 |
| 0d22 |          |           |    |      |    |      | command_completed:     |                                            |
| 0d22 | ad 28 fe | lda $fe28 |  6 |   60 |    |      |                        | lda fdc.status                             |
| 0d25 | 29 7f    | and #$7f  |  2 |   62 |    |      |                        | and #$7f ; indicate not busy               |
| 0d27 | 85 80    | sta $80   |  4 |   66 |    |      |                        | sta command_status                         |
| 0d29 |          |           |    |      |    |      | got_read_byte_counter: |                                            |
| 0d29 |          |           |    |      |    |      | nmi_done:              |                                            |
| 0d29 | a9 ff    | lda #$ff  |  2 |   56 |    |      | relda:                 | lda #$ff                                   |
| 0d2b | 40       | rti       |  7 |   63 |    |      | rti                    |                                            |

* ZX0LOAD1 timings

initial: T=6.87; S=3906/s; D=29810/s

tweaked: T=4.59; S=5846/s; D=44618/s

* zx02 run

#+begin_src python
  argv=[zx02_path,
        cache_uncompressed_path,
        cache_compressed_path]
  subprocess.run(argv,check=True)
#+end_src

* demo memory map

Zero page:

| Region | What            |
|--------+-----------------|
| $0x    |                 |
| $1x    |                 |
| $2x    |                 |
| $3x    |                 |
| $4x    |                 |
| $5x    |                 |
| $6x    |                 |
| $7x    |                 |
| $8x    |                 |
| $9x    |                 |
| $Ax    |                 |
| $Bx    |                 |
| $Cx    |                 |
| $Dx    |                 |
| $Ex    | fdload          |
| $Fx    | fdload/Acorn OS |

Wider main memory use:

| Region   | What              |
|----------+-------------------|
| $00xx    | Zero page         |
| $01xx    | Stack             |
| $02xx    | Acorn OS/reserved |
| $03xx    | fdload            |
| $04xx    | fdload            |
| $05xx    |                   |
| $06xx    |                   |
| $07xx    |                   |
| $08xx    |                   |
| $09xx    |                   |
| $0Axx    |                   |
| $0Bxx    |                   |
| $0Cxx    |                   |
| $0Dxx    | fdload            |
| $0Exx... |                   |

fdload memory is only used while loading stuff from disk and free
otherwise. So while effects are running, all of zero page is free, and
everything from $300 upwards.

This gives space for 100*320 byte character rows, starting from $300.

(101*320 byte rows would start at a problematic $01c0.)

Shadow RAM, HAZEL and ANDY are always free. 102*320 byte character
rows.

(Equivalent 640 byte row counts 

** Acorn OS memory use

Addresses that are unavailable for use:

| Address     | Notes                                       |
|-------------+---------------------------------------------|
| $00fc       | overwritten by IRQ/BRK handler              |
| $0204,$0205 | IRQ1V, called by IRQ/BRK handler if not BRK |

The IRQ/BRK handler initiates a ROM service call before calling BRKV,
so handling BRK properly is going to be annoying, but it could
probably be done if there'd be a need. But there probably won't be;
this would only come in handy for debugging, and that can be done on
an emulator.

Addresses that are ideally unavailable for use:

| Address | Notes                                                                                        |
|---------+----------------------------------------------------------------------------------------------|
| $0258   | memory clear flag (set by OSBYTE 200) - setting this to 3 will hopefully ensure a tidy reset |

** Page $02

IRQ1V will need to be left available, so page $02 is already at least
partly reserved.

Some of what it might be reserved for could go in page $01, but it'd
be nice to leave all of that free.

The main RAM screen start address can't really go below $0300 (see
above), so no harm in reserving all of it.

So, with that in mind, might as well reserve all of it.

Page 2 memory use:

| Address  | What                   | Notes                            |
|----------+------------------------+----------------------------------|
| $0200    | fdload_init            | resident entry point             |
| $0201    |                        |                                  |
| $0202    | BRKV LSB               | Not actually used, but... maybe? |
| $0203    | BRKV MSB               | "                                |
| $0204    | IRQ1V LSB              |                                  |
| $0205    | IRQ1V MSB              |                                  |
| $0206    | fdload_select_bank     | resident entry point             |
| $0207    |                        |                                  |
| $0208    | fdload_restore_bank    | resident entry point             |
| $0209    |                        |                                  |
| $020a    | irq_set_handler        | resident entry point             |
| $020b    |                        |                                  |
| $020c    | irq_reset_handler      | resident entry point             |
| $020d    |                        |                                  |
| $020e    | irq_copy_handler       | resident entry point             |
| $020f    |                        |                                  |
| $0210    |                        |                                  |
| $0211    |                        |                                  |
| $0212    |                        |                                  |
| $0213    |                        |                                  |
| $0214    |                        |                                  |
| $0215    |                        |                                  |
| $0216    |                        |                                  |
| $0217    |                        |                                  |
| $0218    |                        |                                  |
| $0219    |                        |                                  |
| $021a    |                        |                                  |
| $021b    |                        |                                  |
| $021c    |                        |                                  |
| $021d    |                        |                                  |
| $021e    |                        |                                  |
| $021f    |                        |                                  |
| $0220    |                        |                                  |
| $0221    |                        |                                  |
| $0222    |                        |                                  |
| $0223    |                        |                                  |
| $0224    |                        |                                  |
| $0225    |                        |                                  |
| $0226    |                        |                                  |
| $0227    |                        |                                  |
| $0228    |                        |                                  |
| $0229    |                        |                                  |
| $022a    |                        |                                  |
| $022b    |                        |                                  |
| $022c    |                        |                                  |
| $022d    |                        |                                  |
| $022e    |                        |                                  |
| $022f    |                        |                                  |
| $0230    |                        |                                  |
| $0231    |                        |                                  |
| $0232    |                        |                                  |
| $0233    |                        |                                  |
| $0234    |                        |                                  |
| $0235    |                        |                                  |
| $0236    |                        |                                  |
| $0237    |                        |                                  |
| $0238    |                        |                                  |
| $0239    |                        |                                  |
| $023a    |                        |                                  |
| $023b    |                        |                                  |
| $023c    |                        |                                  |
| $023d    |                        |                                  |
| $023e    |                        |                                  |
| $023f    |                        |                                  |
| $0240    |                        |                                  |
| $0241    |                        |                                  |
| $0242    |                        |                                  |
| $0243    |                        |                                  |
| $0244    |                        |                                  |
| $0245    |                        |                                  |
| $0246    |                        |                                  |
| $0247    |                        |                                  |
| $0248    |                        |                                  |
| $0249    |                        |                                  |
| $024a    |                        |                                  |
| $024b    |                        |                                  |
| $024c    |                        |                                  |
| $024d    |                        |                                  |
| $024e    |                        |                                  |
| $024f    |                        |                                  |
| $0250    |                        |                                  |
| $0251    |                        |                                  |
| $0252    |                        |                                  |
| $0253    |                        |                                  |
| $0254    |                        |                                  |
| $0255    |                        |                                  |
| $0256    |                        |                                  |
| $0257    |                        |                                  |
| $0258    | MOS memory clear flags |                                  |
| $0259    |                        |                                  |
| $025a    |                        |                                  |
| $025b    |                        |                                  |
| $025c    |                        |                                  |
| $025d    |                        |                                  |
| $025e    |                        |                                  |
| $025f    |                        |                                  |
| $0260    |                        |                                  |
| $0261    |                        |                                  |
| $0262    |                        |                                  |
| $0263    |                        |                                  |
| $0264    |                        |                                  |
| $0265    |                        |                                  |
| $0266    |                        |                                  |
| $0267    |                        |                                  |
| $0268    |                        |                                  |
| $0269    |                        |                                  |
| $026a    |                        |                                  |
| $026b    |                        |                                  |
| $026c    |                        |                                  |
| $026d    |                        |                                  |
| $026e    |                        |                                  |
| $026f    |                        |                                  |
| $0270    |                        |                                  |
| $0271    |                        |                                  |
| $0272    |                        |                                  |
| $0273    |                        |                                  |
| $0274    |                        |                                  |
| $0275    |                        |                                  |
| $0276    |                        |                                  |
| $0277    |                        |                                  |
| $0278    |                        |                                  |
| $0279    |                        |                                  |
| $027a    |                        |                                  |
| $027b    |                        |                                  |
| $027c    |                        |                                  |
| $027d    |                        |                                  |
| $027e    |                        |                                  |
| $027f    |                        |                                  |
| $0280... | Space for IRQ routine  |                                  |

The space for the IRQ routine is there because it's free, and it's a
useful amount of space for an IRQ handler. But the IRQ handler can go
anywhere.


** Resident entry points

*** =fdload_init=

Entry point for =fdload.init= (see above) to copy fdload routines into
main RAM and make fdload entry points available.

*** =fdload_select_bank=; =fdload_restore_bank=

fdload callbacks, not for general use.

*** =irq_set_handler=

Set IRQ handler to a specific routine: Y=MSB, X=LSB. Disables IRQs
while it does the thing. Save a few bytes compared to inlining the
(not exactly complicated) code.

The IRQ routine must end with `lda $fc:rti`.

*** =irq_reset_handler=

Set IRQ handler to a no-op-ish routine, that acknowledges all system
VIA and user VIA IRQs then returns.

*** =irq_copy_handler=

Copy an IRQ routine to main RAM in page 2, then use =set_irq_handler=
(see above) to set the copy as the IRQ handler.

Max size of IRQ routine is =size(irq_handler_space)= (TODO: should
probably accept this is exactly 128...?), and the max size is always
copied.

IRQs are disabled for the copy. Assume 16 cycles/byte and you won't be
disappointed, probably.

* scroller0

https://discord.com/channels/1256614067070828615/1265647001014374412

| Row | Notes |
|-----+-------|
|   0 |       |
|   1 |       |
|   2 |       |
|   3 |       |
|   4 |       |
|   5 |       |
|   6 |       |
|   7 |       |
|   8 |       |
|   9 |       |
|  10 |       |
|  11 |       |
|  12 |       |
|  13 |       |
|  14 |       |
|  15 |       |
|  16 |       |
|  17 |       |
|  18 |       |
|  19 |       |
|  20 |       |
|  21 |       |
|  22 |       |
|  23 |       |
|  24 |       |
|  25 |       |
|  26 |       |
|  27 |       |
|  28 |       |
|  29 |       |
|  30 |       |
|  31 |       |
|-----+-------|
|  32 |       |
|  33 |       |
|  34 | vsync |
|  35 |       |
|  36 |       |
|  37 |       |
|  38 |       |
|  39 |       |


* can BRK work?

BRK handler code.

If bit 7 is clear in all of $2a1...$2b0, none of the ROM entry points
will be called, and it'll all hang together just about well enough to
fall through to the =jmp (BRKV)=. Maybe.

Since $F4 isn't getting updated, any ROM/paging info will be lost.



#+begin_example
.e59e						irqEntryPoint:
.e59e		85 fc		sta $fc		                sta TEMPA
.e5a0		68		pla		                pla                          ;restore P
.e5a1		48		pha		                pha                          ;save P
.e5a2		29 10		and #$10	                and #$10
.e5a4		d0 03		bne $e5a9	                bne brkEntryPoint
.e5a9						brkEntryPoint:
.e5a9		da		phx		                phx
.e5aa		ba		tsx		                tsx
.e5ab		bd 03 01	lda $0103,x	                lda $0103,x                  ;get BRK address+1 LSB
.e5ae		d8		cld		                cld                          ;
.e5af		38		sec		                sec                          ;
.e5b0		e9 01		sbc #$01	                sbc #$01                     ;get BRK address LSB
.e5b2		85 fd		sta $fd		                sta errPtr+0
.e5b4		bd 04 01	lda $0104,x	                lda $0104,x                  ;get BRK address+1 MSB
.e5b7		e9 00		sbc #$00	                sbc #$00                     ;get BRK address MSB
.e5b9		85 fe		sta $fe		                sta errPtr+1
.e5bb		a5 f4		lda $f4		                lda $F4
.e5bd		8d 4a 02	sta $024a	                sta romActiveAtLastBRK
.e5c0		86 f0		stx $f0		                stx originalX
.e5c2		a2 06		ldx #$06	                ldx #romServiceCallBreakInstruction
.e5c4		20 72 ee	jsr $ee72	                jsr makeROMServiceCall
.e5c7		ae 8c 02	ldx $028c	                ldx currentLanguageROM
.e5ca		20 81 e5	jsr $e581	                jsr selectROMX
.e5cd		fa		plx		                plx
.e5ce		a5 fc		lda $fc		                lda TEMPA
.e5d0		58		cli		                cli
.e5d1		6c 02 02	jmp ($0202)	                jmp (BRKV)

.ee72						makeROMServiceCall: .proc                    ;ee72
.ee72		a5 f4		lda $f4		                lda $F4         ; Save current ROM
.ee74		48		pha		                pha
.ee75		ad 34 fe	lda $fe34	                lda ACCCON      ; Save current paging state
.ee78		48		pha		                pha
.ee79		20 ba ed	jsr $edba	                jsr selectHAZEL ; Page in Hazel
.ee7c		8a		txa		                txa             ; Pass service call number to A
.ee7d		a2 0f		ldx #$0f	                ldx #$0F     ; Start at ROM 15, and always call ROM 15
.ee7f		80 05		bra $ee86	                bra callServiceEntry
.ee81						callServiceEntriesLoop:
.ee81		3c a1 02	bit $02a1,x	                bit romInformationTable,x ;check if ROM X has a service entry
.ee84		10 0b		bpl $ee91	                bpl nextROM       ;branch taken if no service entry
.ee86						callServiceEntry:
.ee86		20 81 e5	jsr $e581	                jsr selectROMX  ; Page in ROM X
.ee89		20 03 80	jsr $8003	                jsr $8003       ; Call ROM service entry point
.ee8c		aa		tax		                tax             ; X = service call result
.ee8d		f0 05		beq $ee94	                beq done       ;branch taken if service call claimed
.ee8f		a6 f4		ldx $f4		                ldx $F4         ; Get ROM number
.ee91						nextROM:
.ee91		ca		dex		                dex       ; Step down to next ROM, loop until all done
.ee92		10 ed		bpl $ee81	                bpl callServiceEntriesLoop

.ee94						done:
.ee94		68		pla		                pla                          ; Restore paging state
.ee95		20 b0 ed	jsr $edb0	                jsr selectMOSOrHAZEL
.ee98		68		pla		                pla                          ; Restore current ROM
.ee99		20 92 e5	jsr $e592	                jsr selectROMA
.ee9c		8a		txa		                txa                          ; Pass claim/noclaim to A
.ee9d		60		rts		                rts
						                .pend

.e581						selectROMX:   ;e581
.e581		86 f4		stx $f4		                stx $F4
.e583		8e 30 fe	stx $fe30	                stx ROMSEL
.e586		60		rts		                rts

.e592		85 f4		sta $f4		                sta $F4         ;update ROMSEL copy
.e594		8d 30 fe	sta $fe30	                sta ROMSEL
.e597		60		rts		                rts

.edba						selectHAZEL:
.edba		a9 08		lda #$08	                lda #ACCCON.Y
.edbc						setACCCONBits:
.edbc		0c 34 fe	tsb $fe34	                tsb ACCCON      ;page in HAZEL at $c000
.edbf		60		rts		                rts
#+end_example

* eof
