                .include "../submodules/beeb/include/beeb.s65"
                .include "shared_constants.s65"
                .include "demo_shared_constants.s65"

*=$00
                .dsection zp
                .cerror *>reserved_zp_begin

*=reserved_zp_begin
                .dsection fdload_zp
                .dsection zx02_zp
                .cerror *>$fc

;-------------------------------------------------------------------------

fdload_banked_version=true
fdload_rom_bank=7

*=loader1_base
                .dsection code
fdload_begin:
                .logical $b800
fdload_dest:
fdload_toc:
                .binary "../build/demo_disk/intermediates/toc.dat"
                .dsection fdload_init_code
fdload_working_code:
                .logical $300
                .dsection fdload_working_code
                .endlogical
                .cerror $>$bffd
*=$bffd
                jsr fdload.init
                .endlogical
fdload_code_end:
resident_begin:
                .logical resident_base
                .dsection resident
                .cerror *>$300
                .endlogical
resident_end:
                .cerror *>loader1_base+loader1_size-16
*=loader1_base+loader1_size-16
                .text loader1_guid

;-------------------------------------------------------------------------

                .section zp
                .endsection

;-------------------------------------------------------------------------

                .section code
                .block
start:
                php
                sei

                ; disable all VIA IRQs
                lda #$7f
                sta user_via.ier
                sta system_via.ier

                ; (If no IRQs enabled, the MOS treats the reset as a
                ; power-on reset, and clears all of RAM - including
                ; sideways RAM in MOS 3.50. Not actually a problem in
                ; this case.)
                
                ldx #resident_end-resident_begin-1
copy_resident_loop:
                lda resident_begin,x
                sta resident_base,x
                dex
                bpl copy_resident_loop

                plp

                jsr fdload_select_bank
                
                ldx #8          ; 2 KB
                ldy #0
copy_fdload_loop:
lda_fdload_byte: lda fdload_begin,y
sta_fdload_byte: sta fdload_dest,y

                lda #0
                sta fdload_begin,y

                iny
                bne copy_fdload_loop

                inc lda_fdload_byte+2
                inc sta_fdload_byte+2
                dex
                bne copy_fdload_loop

                ; fdload_select_bank setting remains in effect.
                jsr fdload.one_time_init

                lda #4
                sta romsel
                
                jsr fdload_load_file_contents
                .word demo_scroller1_begin
                .byte $b0
                .byte file_scroller1_bin

                .endblock
                
                .endsection code

;-------------------------------------------------------------------------

                .section resident
                .cerror *!=fdload_init
                bra fdload_init_2
                .word 0         ; BRKV
                .word null_irq  ; IRQ1V
                .cerror *!=fdload_select_bank
                bra fdload_select_bank_2
                .cerror *!=fdload_restore_bank
                bra fdload_restore_bank_2
                .cerror *!=irq_set_handler
                bra irq_set_handler_2
                .cerror *!=irq_reset_handler
                bra irq_reset_handler_2
                .cerror *!=irq_copy_handler
                bra irq_copy_handler_2
fdload_init_2:
                jsr fdload_select_bank_2
                phy
                lda #fdload_rom_bank
                sta romsel
                jsr fdload.init
                ply
                .cerror *!=fdload_restore_bank_2
fdload_restore_bank_2:
                sty romsel
                rts
fdload_select_bank_2:
                ldy romsel
                ldx #fdload_rom_bank
                stx romsel
                rts
irq_reset_handler_2:
                ldy #>null_irq
                ldx #<null_irq
                .cerror *!=irq_set_handler_2
irq_set_handler_2:
                php
                sei
irq_set_handler_3:
                stx irq1v+0
                sty irq1v+1
                plp
                rts
irq_copy_handler_2: .block
                php
                sei
                stx lda_handler_byte+1
                sty lda_handler_byte+2
                .cerror size(irq_handler_space)!=128
                ldx #0
loop:
lda_handler_byte: lda $ffff,x
                sta irq_handler_space,x
                inx
                bpl loop
                ; X=$80 at this point, so save a couple of bytes...
                .cerror (<irq_handler_space)!=$80
                ldy #>irq_handler_space
                bra irq_set_handler_3
                .endblock

                ; ~11 bytes free here
                .cerror *>$258
                .fill $258-*
                .byte 3         ; MOS memory clear flags
null_irq:
                lda system_via.ifr
                bpl +
                sta system_via.ifr
+
                lda user_via.ifr
                bpl +
                sta user_via.ifr
+
                lda $fc
                rti
                .endsection resident

;-------------------------------------------------------------------------

                .include "fdload.s65"

                .cerror fdload.load_file_contents!=fdload_load_file_contents
                .cerror fdload.load_file_disk_data!=fdload_load_file_disk_data

;-------------------------------------------------------------------------
