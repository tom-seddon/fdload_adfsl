                .include "../submodules/beeb/include/beeb.s65"

;-------------------------------------------------------------------------

ZP_BASE=$80
CODE_BASE=$2800

;-------------------------------------------------------------------------

                .weak
include_test_hooks=false
verbose_wait_for_command=false
debug=false
                .endweak
                
;-------------------------------------------------------------------------

; BIT_immediate=$89
; BRA_relative=$80

BIT_immediate=$89
BRA_relative=$80
STA_absolute=$8d
RTI_implicit=$40
                
;-------------------------------------------------------------------------

                .virtual $fe28
fdc: .block
status:
command:
                .fill 1
track:
                .fill 1
sector:
                .fill 1
data:
                .fill 1
                .endblock
                .endvirtual

                .virtual $fe24
fdc_control: .block
drive0=1
drive1=2
not_reset=4
side2=16
not_dden=32
                .endblock
                .endvirtual                
                
;-------------------------------------------------------------------------

*=ZP_BASE
                .dsection fixed_zp
                .dsection other_zp
                .cerror *>ZP_BASE+256

*=CODE_BASE
                .dsection code
                .cerror *>CODE_BASE+256

;-------------------------------------------------------------------------

; 0xxx = enable spin-up sequence
h_flag_value=%0000
                
; 1xx = verify dest track
; x00 = 6 ms step time
; x01 = 12 ms step time
type_i_flags=h_flag_value|%100

; ; 0xx = no 30 ms settling delay
; type_ii_flags=h_flag_value|%000
                
;-------------------------------------------------------------------------

                .section fixed_zp
                ; bit 7 set if busy: the motor status bit is repurposed.
command_status: .fill 1
read_byte_addr: .fill 2
read_byte_counter: .fill 2
                .endsection

                .section other_zp
                .if debug
num_nmis: .fill 1
                .endif
                .endsection
                
;-------------------------------------------------------------------------

                .section code

                .if include_test_hooks
                jmp init        ; +0
                jmp restore     ; +3
                jmp seek        ; +6
                jmp read        ; +9
                .if debug       ; +12
                lda num_nmis
                .else
                lda #0
                .endif
                rts
                .endif

;-------------------------------------------------------------------------

init:                
                jsr cancel

                ; copy to $d01. $d00 is RTI, for now, and will get
                ; fixed up as required.
                ldx #size(nmi_routine)-1
-
                lda nmi_routine,x
                sta $d01,x
                dex
                bpl -

                stz command_status
                .if debug
                stz num_nmis
                .endif

                rts

;-------------------------------------------------------------------------

cancel:
                lda #RTI_implicit
                sta $d00
                lda #%11010000  ; Type IV Force Interrupt
                sta fdc.command

                .cerror *!=wait_32us

; The jsr/rts overhead isn't included in the delay, so the routine can
; be fallen through into in at least one case.

; Cycles = 2+2N+3(N-1)+2 = 2+2N+3N-3+2 = 2+5N-3+2 = 2+5N+1 = 3+5N
                
wait_32us:
                lda #13
wait_32us_loop:
                dec a
                bne wait_32us_loop
                rts

;-------------------------------------------------------------------------

restore:
                ldy #%00000000|type_i_flags ; Type I Restore
                clc                         ; select side 0
                .cerror *!=perform_seek_type_command

; Y=Type I command to perform
perform_seek_type_command:
                ldx #BRA_relative
                jsr prepare_fdc_and_nmi_routine_for_command
                sty fdc.command
                .cerror *!=wait_for_command
wait_for_command:
                .if verbose_wait_for_command
                lda #'W'
                jsr oswrch
                .endif
wait_for_command_loop:
                bit command_status
                bmi wait_for_command_loop
                .if verbose_wait_for_command
                lda #8
                jsr oswrch
                lda #' '
                jsr oswrch
                lda #8
                jsr oswrch
                .endif
                rts

;-------------------------------------------------------------------------

; A = logical track.
;
; Will also select appropriate side.

seek:
                lsr a           ; C=disk side
                sta fdc.data    ; select dest phys track for seek

                ldy #%00010000|type_i_flags ; Type I Seek
                bra perform_seek_type_command

;-------------------------------------------------------------------------

; A = start sector on current track
;
; read_byte_addr.w = where to write the data
;
; read_byte_counter.w = negated number of bytes to read

read:
                sta fdc.sector

                ; don't update the FDC control reg. The restore/seek
                ; will have set it to the right value.
                ldx #BIT_immediate
                jsr prepare_nmi_routine_for_command

                lda #%10010000|h_flag_value
                sta fdc.command

                jsr wait_for_command
                rts
                
                
;-------------------------------------------------------------------------

; X=opcode to poke into nmi_routine.branch
; C=0 to select side 0; C=1 to select side 2
prepare_fdc_and_nmi_routine_for_command:
                lda #fdc_control.drive0|fdc_control.not_reset
                bcc +
                ora #fdc_control.side2
+
                sta fdc_control
                .cerror *!=prepare_nmi_routine_for_command
prepare_nmi_routine_for_command:
                ; fix up the NMI routine.
                lda #STA_absolute
                sta $d00
                stx nmi_routine.branch

                ; indicate thing is busy.
                sec
                ror command_status
                rts

;-------------------------------------------------------------------------

nmi_routine: .block
                ; $d00 is looked after manually. See comments above.
                .logical $d01
                .word relda+1   ; operand for STA absolute

                .if debug
                inc num_nmis
                .endif

                ; replace with $89 (BIT immediate, 2 cycles) to create
                ; the read data NMI routine.
branch:
                bra command_completed
                lda fdc.status
                bit #%00011100  ; RnF/CRC/Lost Data errors
                bne cancel_command ; 
                lda fdc.data
                sta (read_byte_addr)
                inc read_byte_addr+0
                bne got_read_byte_addr
                inc read_byte_addr+1
got_read_byte_addr:
                inc read_byte_counter+0
                bne got_read_byte_counter
                inc read_byte_counter+1
                bne got_read_byte_counter
cancel_command:
                ; Read done.
                jsr cancel
command_completed:
                lda fdc.status
                and #$7f ; indicate not busy
                sta command_status
got_read_byte_counter:
nmi_done:
relda: lda #$ff
                rti
                .endlogical
                .endblock

                .endsection

;-------------------------------------------------------------------------
