                .include "../submodules/beeb/include/beeb.s65"

;-------------------------------------------------------------------------

ZP_BASE=$80
CODE_BASE=$2800

;-------------------------------------------------------------------------

                .weak
test_build=false
verbose_wait_for_command=false
debug=false
                .endweak

;-------------------------------------------------------------------------

; BIT_immediate=$89
; BRA_relative=$80

BIT_immediate=$89
BRA_relative=$80
STA_absolute=$8d
RTI_implicit=$40
                
;-------------------------------------------------------------------------

TOCEntry: .struct
                ; logical track to start reading from.
ltrack: .fill 1

                ; sector to start reading from.
sector: .fill 1

                ; negated size of file in bytes.
negative_size: .fill 2
                .endstruct
                
                .virtual $fe28
fdc: .block
status:
command:
                .fill 1
track:
                .fill 1
sector:
                .fill 1
data:
                .fill 1
                .endblock
                .endvirtual

                .virtual $fe24
fdc_control: .block
drive0=1
drive1=2
not_reset=4
side2=16
not_dden=32
                .endblock
                .endvirtual                
                
;-------------------------------------------------------------------------

*=ZP_BASE
                .dsection fixed_zp
                .dsection zx02_zp
                .dsection other_zp
                .cerror *>ZP_BASE+256

*=CODE_BASE
                .dsection fdload_code
                .dsection zx02_code
toc_data:
                .cerror *>CODE_BASE+512
                .if test_build
                .binary "../build/boot.toc.dat"
                .endif

;-------------------------------------------------------------------------

; 0xxx = enable spin-up sequence
h_flag_value=%0000
                
; 1xx = verify dest track
; x00 = 6 ms step time
; x01 = 12 ms step time
type_i_flags=h_flag_value|%101

; ; 0xx = no 30 ms settling delay
; type_ii_flags=h_flag_value|%000
                
;-------------------------------------------------------------------------

                .section fixed_zp
                ; bit 7 set if busy: the motor status bit is repurposed.
command_status: .fill 1
read_byte_addr: .fill 2
read_byte_counter: .fill 2
                .endsection

                .section other_zp
                .if debug
num_nmis: .fill 1
                .endif
argptr: .fill 2
toc_entry: .dstruct TOCEntry
                .endsection
                
;-------------------------------------------------------------------------

                .section fdload_code

                .if test_build
                jmp init        ; +0
                jmp restore     ; +3
                jmp seek        ; +6
                jmp read        ; +9
                .if debug       ; +12
                lda num_nmis
                .else
                lda #0
                .endif
                rts
                jmp test_read   ; +15
                .endif

;-------------------------------------------------------------------------

                .if test_build
test_read: .block
                sta $ffff
                sta file_index
                jsr load_uncompressed_file
                .word $3000
file_index: .byte 0
                sta $fffe
                rts
                .endblock
                .endif
                
;-------------------------------------------------------------------------

init: .block
                jsr cancel

                ; copy to $d01. $d00 is RTI, for now, and will get
                ; fixed up as required.
                ldx #size(nmi_routine)-1
-
                lda nmi_routine,x
                sta $d01,x
                dex
                bpl -

                stz command_status
                .if debug
                stz num_nmis
                .endif

                rts
                .endblock

;-------------------------------------------------------------------------

cancel: .block
                lda #RTI_implicit
                sta $d00
                lda #%11010000  ; Type IV Force Interrupt
                sta fdc.command
                .cerror *!=wait_32us
                .endblock

; The jsr/rts overhead isn't included in the delay, so the routine can
; be fallen through into in at least one case.

; Cycles = 2+2N+3(N-1)+2 = 2+2N+3N-3+2 = 2+5N-3+2 = 2+5N+1 = 3+5N
                
wait_32us: .block
                lda #13
-
                dec a
                bne -
                rts
                .endblock

;-------------------------------------------------------------------------

restore: .block
                ldy #%00000000|type_i_flags ; Type I Restore
                clc                         ; select side 0
                .cerror *!=perform_seek_type_command
                .endblock
                
; Y=Type I command to perform
perform_seek_type_command: .block
                ldx #BRA_relative
                jsr prepare_fdc_and_nmi_routine_for_command
                sty fdc.command
                .cerror *!=wait_for_command
                .endblock
wait_for_command: .block
                .if verbose_wait_for_command
                lda #'W'
                jsr oswrch
                .endif
wait_for_command_loop:
                bit command_status
                bmi wait_for_command_loop
                .if verbose_wait_for_command
                lda #8
                jsr oswrch
                lda #' '
                jsr oswrch
                lda #8
                jsr oswrch
                .endif
                rts
                .endblock

;-------------------------------------------------------------------------

; A = logical track.
;
; Will also select appropriate side.

seek: .block
                lsr a           ; C=disk side
                sta fdc.data    ; select dest phys track for seek

                ldy #%00010000|type_i_flags ; Type I Seek
                bra perform_seek_type_command
                .endblock

;-------------------------------------------------------------------------
;
; Entry:
; 
; A = start sector on current track
;
; read_byte_addr.w = where to write the data
;
; read_byte_counter.w = negated number of bytes to read

read: .block
                sta fdc.sector

                ; don't update the FDC control reg. The restore/seek
                ; will have set it to the right value.
                ldx #BIT_immediate
                jsr prepare_nmi_routine_for_command

                lda #%10010000|h_flag_value
                sta fdc.command

                bra wait_for_command
                .endblock
                
;-------------------------------------------------------------------------

; X=opcode to poke into nmi_routine.branch
; C=0 to select side 0; C=1 to select side 2
prepare_fdc_and_nmi_routine_for_command: .block
                lda #fdc_control.drive0|fdc_control.not_reset
                bcc +
                ora #fdc_control.side2
+
                sta fdc_control
                .cerror *!=prepare_nmi_routine_for_command
                .endblock
prepare_nmi_routine_for_command: .block
                ; fix up the NMI routine.
                lda #STA_absolute
                sta $d00
                stx nmi_routine.branch

                ; indicate thing is busy.
                sec
                ror command_status
                rts
                .endblock

;-------------------------------------------------------------------------

nmi_routine: .block
                ; $d00 is looked after manually. See comments above.
                .logical $d01
                .word relda+1   ; operand for STA absolute

                .if debug
                inc num_nmis
                .endif

                ; replace with $89 (BIT immediate, 2 cycles) to create
                ; the read data NMI routine.
branch:
                bra command_completed
                lda fdc.status
                bit #%00011100  ; RnF/CRC/Lost Data errors
                bne cancel_command ; 
                lda fdc.data
                sta (read_byte_addr)
                inc read_byte_addr+0
                bne got_read_byte_addr
                inc read_byte_addr+1
got_read_byte_addr:
                inc read_byte_counter+0
                bne got_read_byte_counter
                inc read_byte_counter+1
                bne got_read_byte_counter
cancel_command:
                ; Read done.
                jsr cancel
command_completed:
                lda fdc.status
                and #$7f ; indicate not busy
                sta command_status
got_read_byte_counter:
nmi_done:
relda: lda #$ff
                rti
                .endlogical
                .endblock

;-------------------------------------------------------------------------

fetch_caller_arg: .block
                inc $101,x
                bne +
                inc $102,x
+
                lda $101,x
                sta lda_byte+1
                lda $102,x
                sta lda_byte+2
lda_byte: lda $ffff
                rts
                .endblock

load_uncompressed_file: .block
                ; get file index.
                tsx
                
                ; get dest address
                jsr fetch_caller_arg
                sta read_byte_addr+0
                jsr fetch_caller_arg
                sta read_byte_addr+1

                ; get file index
                jsr fetch_caller_arg ; ABCDEFGH
                
                ; form toc address.
                asl a           ; BCDEFGH0 A
                rol a           ; CDEFGH0A B
                rol a           ; DEFGH0AB C
                tax
                ror a           ; CDEFGH0A
                and #%11111100  ; CDEFGH00
                clc
                adc #<toc_data
                sta lda_toc_entry_byte+1
                txa
                and #%00000011  ; 000000AB
                adc #>toc_data
                sta lda_toc_entry_byte+2

                ldx #size(TOCEntry)-1
-
lda_toc_entry_byte: lda $ffff,x
                sta toc_entry,x
                dex
                bpl -

                ; 0-byte files are not a thing.
read_file_loop:
                ; fill out the byte count for the read.
                jsr get_read_byte_counter

                ; seek to the track.
                lda toc_entry.ltrack
                jsr seek

                ; do the read.
                lda toc_entry.sector
                jsr read

                ; get the read counter again.
                jsr get_read_byte_counter

                ; prepare for next read. bump the track counter.
                ; always start from sector 0 on subsequent tracks.
                inc toc_entry.ltrack

                lda toc_entry.sector
                and #$f0
                sta toc_entry.sector

                ; bump bytes left by quantity read.
                sec
                lda toc_entry.negative_size+0
                sbc read_byte_counter+0
                sta toc_entry.negative_size+0
                lda toc_entry.negative_size+1
                sbc read_byte_counter+1
                sta toc_entry.negative_size+1

                bne read_file_loop

                rts

                ; still some bytes left? keep going.
                bne read_file_loop
                bcc read_file_loop
                rts

get_read_byte_counter:
                lda toc_entry.negative_size+1
                cmp #$f0
                bcs in_last_4KB

not_in_last_4KB:
                ; read as much as is left on the track given the start
                ; sector - max 4096 bytes.
                ;
                ; -4096=$f000, -256=$ff00. The constant can be
                ; -generated from the sector number.
                lda toc_entry.sector
                ora #$f0
                sta read_byte_counter+1
                stz read_byte_counter+0
                rts

in_last_4KB:
                sta read_byte_counter+1
                lda toc_entry.negative_size+0
                sta read_byte_counter+0
                rts

                .endblock

                .endsection

;-------------------------------------------------------------------------

                .section zx02_zp
ZP:
offset: .fill 2
bitr: .fill 1
ZX0_dst: .fill 2
ZX0_src: .fill 2
pntr: .fill 2
setx: .fill 1
                .endsection
                
                .section zx02_code

out_addr=$3000
comp_data=$4000

zx0_ini_block
                .word 0 ; Initial offset - 1. See README for explanation (-o option).
                .byte $80 ; Initial value for the bit reservoir. Don't ever change.
                .word out_addr  ; Address to place decompressed data
                .word comp_data   ; Address of data to decompress.
                
;--------------------------------------------------
; Decompress ZX0 data (6502 optimized format)
;
; Reads data from 'comp_data' and writes the result to 'out_addr', until the
; compressed data ends.

full_decomp: .block
; Get initialization block
                ldx #6

copy_init:
                lda zx0_ini_block,x
                sta offset,x
                dex
                bpl copy_init

                ; Init: X = -2
                dex

                ; Decode literal: Copy next N bytes from compressed file
                ;    Elias(length)  byte[1]  byte[2]  ...  byte[N]
decode_literal:
                ldy   #1
                jsr   get_elias
                jsr   put_byte
                bcs   dzx0s_new_offset

                ; Copy from last offset (repeat N bytes from last offset)
                ;    Elias(length)
                iny
                jsr   get_elias
dzx0s_copy:
; C=0 from get_elias
sbc1:
                lda   ZX0_dst+2,x
                sbc   offset+2,x
                sta   pntr+2,x
                inx
                bne   sbc1

                jsr   put_byte
                bcc   decode_literal

                ; Copy from new offset (repeat N bytes from new offset)
                ;    Elias(MSB(offset))  LSB(offset)  Elias(length-1)
dzx0s_new_offset:
; Read elias code for high part of offset
                iny
                jsr   get_elias
                beq   exit  ; Read a 0, signals the end
                ; Decrease and divide by 2
                dey
                tya
                lsr   a
                sta   offset+1

                ; Get low part of offset, a literal 7 bits
                jsr   get_byte

                ; Divide by 2
                ror   a
                sta   offset

                ; And get the copy length.
                ; Start elias reading with the bit already in carry:
                ldy   #1
                jsr   elias_skip1

                iny
                bcc   dzx0s_copy

; Read an elias-gamma interlaced code.
; ------------------------------------
elias_loop:
; Read next data bit to result
                asl   bitr
                rol   a
                tay

get_elias:
; Get one bit
                asl   bitr
                bne   elias_skip1

                ; Read new bit from stream
                jsr   get_byte
                ;sec   ; not needed, C=1 guaranteed from last bit
                rol   a
                sta   bitr

elias_skip1:
                tya
                bcs   elias_loop
                ; Got ending bit, stop reading
                rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

get_byte:
                lda   (ZX0_src+2,x)
                inc   ZX0_src+2,x
                bne   +
                inc   ZX0_src+3,x
exit:
+
                rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

put_byte:
                stx   setx
ploop:
                ldx   setx
                jsr   get_byte
                ldx   #$FE
                sta   (ZX0_dst+2,x)
                inc   ZX0_dst
                bne   +
                inc   ZX0_dst+1
+
                dey
                bne   ploop
                asl   bitr
                rts
                .endblock
                .endsection

                