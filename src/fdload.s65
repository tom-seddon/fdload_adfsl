; ;-------------------------------------------------------------------------

; ZP_BASE=$80
; CODE_BASE=$2800

; ;-------------------------------------------------------------------------

                .weak
fdload_debug=false
fdload_verbose=false

                ; if true, build the ROM banked version, designed to
                ; live in a ROM bank at $bc00 with the TOC at $b800.
fdload_banked_version=false
                .endweak

;-------------------------------------------------------------------------

fdload_entry_points_base=$d80
                
;-------------------------------------------------------------------------

; BIT_immediate=$89
; BRA_relative=$80

BIT_immediate=$89
BRA_relative=$80
STA_absolute=$8d
RTI_implicit=$40
                
;-------------------------------------------------------------------------

TOCHeader: .struct
num_files:
                .fill 1
                .endstruct
                
TOCEntry: .struct
                ; logical track to start reading from.
ltrack: .fill 1

                ; sector to start reading from.
sector_and_flags: .fill 1

                ; negated size of file in bytes.
negative_size: .fill 2
                .endstruct
                
                .virtual $fe28
fdc: .block
status:
command:
                .fill 1
track:
                .fill 1
sector:
                .fill 1
data:
                .fill 1
                .endblock
                .endvirtual

                .virtual $fe24
fdc_control: .block
drive0=1
drive1=2
not_reset=4
side2=16
not_dden=32
                .endblock
                .endvirtual                
                
;-------------------------------------------------------------------------

; *=ZP_BASE
;                 .dsection fixed_zp
;                 .dsection zx02_zp
;                 .dsection other_zp
;                 .cerror *>ZP_BASE+256

; *=CODE_BASE
;                 .dsection fdload_code
;                 .dsection zx02_code
; zx02_workspace:
;                 .dsection zx02_workspace

; toc_header: .dstruct TOCHeader
;toc_entries:
;                 .if test_build
; *=toc_header
;                 .binary "../build/test_disk/intermediates/toc.dat"
;                 .endif
;                 .cerror *>$3000

;-------------------------------------------------------------------------

; 0xxx = enable spin-up sequence
h_flag_value=%0000
                
; 1xx = verify dest track
; x00 = 6 ms step time
; x01 = 12 ms step time
type_i_flags=h_flag_value|%101

; ; 0xx = no 30 ms settling delay
; type_ii_flags=h_flag_value|%000

;-------------------------------------------------------------------------

fdload: .block

                .logical fdload_toc
                .virtual
toc_header: .dstruct TOCHeader
toc_entries:
                .endvirtual
                .endlogical
                
;-------------------------------------------------------------------------

                .section fdload_zp
                ; bit 7 set if busy: the motor status bit is repurposed.
command_status: .fill 1
read_byte_addr: .fill 2
read_byte_counter: .fill 2
toc_entry: .dstruct TOCEntry
offset: .fill 2
bitr: .fill 1
ZX0_dst: .fill 2
ZX0_src: .fill 2
pntr: .fill 2
                .endsection

;-------------------------------------------------------------------------

                .section fdload_init_code

; fdload code that can go in a banked section. it doesn't need to be
; paged in while the transfer is ongoing.

;-------------------------------------------------------------------------

one_time_init: .block
                jsr init
                jmp restore
                .endblock
                
init: .block
                .if fdload_banked_version

working_code_size=working_code_end-working_code_begin
                .cerror working_code_size>512

                ldx #0
copy_fdload_working_code_loop:
                lda fdload_working_code,x
                sta working_code_begin,x
                .if working_code_size>256
                ; this will overwrite some bytes with the same value.
                ; oh well.
                lda fdload_working_code+working_code_size-256,x
                sta working_code_begin+working_code_size-256,x
                .endif
                inx
                bne copy_fdload_working_code_loop
                
                .endif

                ; this just assumes there is no 1770 command ongoing!
                
                ldx #size(nmi_routine)-1
copy_nmi_routine_loop:
                lda nmi_routine_code,x
                sta $d01,x
                dex
                bpl copy_nmi_routine_loop

                ldx #size(entry_points)-1
copy_entry_points_loop:
                lda entry_points,x
                sta fdload_entry_points_base,x
                dex
                bpl copy_entry_points_loop

                jsr nmi_routine.cancel
                stz command_status

                rts
                .endblock

;-------------------------------------------------------------------------
;
; Initialise file read.
;
; (The actual entry point is file_read_init - either an alias for this
; label, or a routine that handles paging in the fdload init area.)
;
; Entry:
; 
; A = file index
;
; Exit:
;
; toc_entry - initialised
;
; Preserves: Y
                
file_read_init_2: .block
                ; don't read bogus TOC data! The drive can only go as
                ; far as track 79...
                cmp toc_header.num_files
                bcs done

                ; form toc address.
                asl a           ; BCDEFGH0 A
                rol a           ; CDEFGH0A B
                rol a           ; DEFGH0AB C
                tax
                ror a           ; CDEFGH0A
                and #%11111100  ; CDEFGH00
                clc
                adc #<toc_entries
                sta lda_toc_entry_byte+1
                txa
                and #%00000011  ; 000000AB
                adc #>toc_entries
                ; C=0
                sta lda_toc_entry_byte+2

                ldx #size(TOCEntry)-1
-
lda_toc_entry_byte: lda $ffff,x
                sta toc_entry,x
                dex
                bpl -
done:
                rts
                .endblock
                
;-------------------------------------------------------------------------

nmi_routine_code:
                .logical $d01
nmi_routine: .block
                .byte complete_command-(*+1) ; operand for BRA
                
                sta relda+1

                lda fdc.data
                sta (read_byte_addr)
                inc read_byte_counter+0
                bne got_read_byte_counter
                inc read_byte_counter+1
                bne got_read_byte_counter
cancel_command:
                ; Read done.
                jsr cancel
                lsr command_status
got_read_byte_counter:
                inc read_byte_addr+0
                bne got_read_byte_addr
                inc read_byte_addr+1
got_read_byte_addr:
nmi_done:
relda: lda #$ff
                rti

; X=opcode to poke into first byte of NMI routine
; C=0 to select side 0; C=1 to select side 2
prepare_fdc_and_nmi_routine_for_command: .block
                lda #fdc_control.drive0|fdc_control.not_reset
                bcc +
                ora #fdc_control.side2
+
                sta fdc_control
                .cerror *!=prepare_nmi_routine_for_command
                .endblock
; X=opcode to poke into first byte of NMI routine
prepare_nmi_routine_for_command: .block
                stx $d00

                ; indicate thing is busy.
                sec
                ror command_status
                rts
                .endblock
                
cancel:
                lda #RTI_implicit
                sta $d00
                lda #%11010000  ; Type IV Force Interrupt
                sta fdc.command
; Cycles = 2+2N+3(N-1)+2 = 2+2N+3N-3+2 = 2+5N-3+2 = 2+5N+1 = 3+5N
                lda #13
-
                dec a
                bne -
                rts

complete_command:
                lsr command_status
                rti
                .endblock

                .virtual
zx02_workspace:
ZX0_resume_state: .fill 1
ZX0_src_buf_end_page: .fill 1
stack_buf_size: .fill 1
entry_s: .fill 1
stack_buf: .fill 12             ; hopefully sufficient
                .endvirtual
                
                .cerror *>fdload_entry_points_base
                .endlogical

entry_points: .block
                .logical fdload_entry_points_base
load_file_contents:
                jmp load_file_contents_routine
load_file_disk_data:
                jmp load_file_disk_data_routine
                .endlogical
                .endblock

                .endsection fdload_init_code

load_file_contents=entry_points.load_file_contents
                .cerror load_file_contents!=fdload_entry_points_base+0*3
load_file_disk_data=entry_points.load_file_disk_data
                .cerror load_file_disk_data!=fdload_entry_points_base+1*3
                
;-------------------------------------------------------------------------

                .section fdload_working_code

working_code_begin:
                
;-------------------------------------------------------------------------

                .if fdload_verbose
print_value:
                pha
                lda #' '
                jsr oswrch
                txa
                jsr oswrch
                lda #'='
                jsr oswrch
                pla
                pha
                jsr print_byte
                pla
                rts
                
print_byte:
                pha
                lsr a
                lsr a
                lsr a
                lsr a
                jsr print_nybble
                pla
                and #$0f
print_nybble:
                sed
                clc
                adc #$90
                adc #$40
                cld
                jmp oswrch
                .endif

;-------------------------------------------------------------------------

; cancel: .block
;                 lda #RTI_implicit
;                 sta $d00
;                 lda #%11010000  ; Type IV Force Interrupt
;                 sta fdc.command
;                 .cerror *!=wait_32us
;                 .endblock

; ; The jsr/rts overhead isn't included in the delay, so the routine can
; ; be fallen through into in at least one case.

; ; Cycles = 2+2N+3(N-1)+2 = 2+2N+3N-3+2 = 2+5N-3+2 = 2+5N+1 = 3+5N
                
; wait_32us: .block
;                 lda #13
; -
;                 dec a
;                 bne -
;                 rts
;                 .endblock

;-------------------------------------------------------------------------

restore: .block
                ldy #%00000000|type_i_flags ; Type I Restore
                clc                         ; select side 0
                .cerror *!=perform_seek_type_command
                .endblock
                
; Y=Type I command to perform
perform_seek_type_command: .block
                ldx #BRA_relative
                jsr nmi_routine.prepare_fdc_and_nmi_routine_for_command
                sty fdc.command
                .cerror *!=wait_for_command
                .endblock
wait_for_command: .block
                .if fdload_verbose
                lda #'W'
                jsr oswrch
                .endif
wait_for_command_loop:
                bit command_status
                bpl command_done

                ; lda fdc.status
                ; bit #1
                ; beq command_done

                jmp wait_for_command_loop

command_done:
                lda fdc.status
                sta command_status
                
                .if fdload_verbose
                lda #8
                jsr oswrch
                lda #' '
                jsr oswrch
                lda #8
                jsr oswrch
                .endif
                rts
                .endblock

;-------------------------------------------------------------------------

; A = logical track.
;
; Will also select appropriate side.

seek: .block
                .if fdload_verbose
                phx
                ldx #'T'
                jsr print_value
                plx
                .endif
                
                lsr a           ; C=disk side
                sta fdc.data    ; select dest phys track for seek

                ldy #%00010000|type_i_flags ; Type I Seek
                bra perform_seek_type_command
                .endblock

;-------------------------------------------------------------------------
;
; Entry:
; 
; A = start sector on current track
;
; read_byte_addr.w = where to write the data
;
; read_byte_counter.w = negated number of bytes to read

read: .block
                .if fdload_verbose
                phx
                ldx #'S'
                jsr print_value
                plx
                .endif
                
                sta fdc.sector

                ; don't update the FDC control reg. The restore/seek
                ; will have set it to the right value.
                ldx #BIT_immediate
                jsr nmi_routine.prepare_nmi_routine_for_command

                ; xxx1xxxx = read multiple sectors
                lda #%10010000|h_flag_value ; Type II Read Sector
                sta fdc.command
                .if fdload_verbose
                phx
                ldx #'C'
                jsr print_value
                plx
                .endif

                bra wait_for_command
                .endblock
                
;-------------------------------------------------------------------------
;
; Preserves: Y
; 
fetch_caller_arg: .block
                inc $101,x
                bne +
                inc $102,x
+
                lda $101,x
                sta lda_byte+1
                lda $102,x
                sta lda_byte+2
lda_byte: lda $ffff
                rts
                .endblock

;-------------------------------------------------------------------------
;
; Entry:
; 
; caller args:
; 
; .word dest_address - where to load the data to
;
; .byte file_index - index of file

load_file_disk_data_routine: .block
                tsx
;got_s:
                ; get dest address
                jsr fetch_caller_arg
                sta read_byte_addr+0
                jsr fetch_caller_arg
                sta read_byte_addr+1

                ; get file index
                jsr fetch_caller_arg

                jsr file_read_init
                bcs done        ; taken if invalid file

loop:
                jsr file_read_next_track
                bcs loop

done:
                ; load file disk data only ever loads the data. it
                ; ignores the execute flag.
                rts
                .endblock

;-------------------------------------------------------------------------
;
; Entry:
;
; caller args:
;
; .word dest_address - where to uncompress the data to
;
; .byte buffer_msb - MSB of page-aligned 4 KB buffer to read each bit of file into in the compressed case
;
; .byte file_index - index of file
                
load_file_contents_routine: .block
                tsx
                
                ; get dest address. Set up dest addresses for both
                ; compressend and uncompressed cases, as it's shorter
                ; than trying to fix that up later.
                jsr fetch_caller_arg
                sta ZX0_dst+0
                sta read_byte_addr+0
                sta jmp_load_address+1
                jsr fetch_caller_arg
                sta ZX0_dst+1
                sta read_byte_addr+1
                sta jmp_load_address+2

                ; get buffer address MSB
                jsr fetch_caller_arg
                pha             ; save buffer address MSB

                ; ; form buffer end address MSB
                ; clc
                ; adc #>4096
                ; sta ZX0_src_buf_end_page

                ; get file index
                jsr fetch_caller_arg
                jsr file_read_init
                pla             ; restore buffer address MSB
                bcs done        ; taken if invalid file

                ; check for compressed file. 
                bit toc_entry.sector_and_flags
                bpl load_uncompressed

                ; indicate resumable operation
                ldx #$80
                stx ZX0_resume_state

loop:
                pha             ; save buffer address MSB

                ; Form disk read address.
                stz read_byte_addr+0
                sta read_byte_addr+1

                ; form ZX0 source address. Same.
                stz ZX0_src+0
                sta ZX0_src+1

                ; read next bit
                jsr file_read_next_track
                ;php             ; save eof flag

                ; Fix up buffer end address. 
                sec
                lda ZX0_src+1
                sbc read_byte_counter+1
                sta ZX0_src_buf_end_page

                ; decompress next bit
                jsr full_decomp

                ; ; restore C
                ; pla
                ; pha
                ; plp

                pla             ; restore buffer address MSB

                ; always only loop until end of data. if the last byte
                ; of the file is the last byte of the buffer, when
                ; full_decomp returns, there's still 1 byte to process
                ; and it needs to be called once more.
                bit ZX0_resume_state
                bmi loop        ; taken if still more zx02 data

maybe_execute:
                ; if execute flag set, jump to the load address.
                bit toc_entry.sector_and_flags
                bvs execute
                
done:
                rts

load_uncompressed:
                jsr load_file_disk_data_routine.loop
                bra maybe_execute

execute:
                ldx #$ff
                txs
jmp_load_address: jmp $ffff

                .endblock

;-------------------------------------------------------------------------
;

                .if fdload_banked_version

file_read_init:
                jsr fdload_select_bank
                phx
                phy

                jsr file_read_init_2

                ply
                plx
                jsr fdload_restore_bank

                rts

                .else

file_read_init=file_read_init_2

                .endif

                
;-------------------------------------------------------------------------
;
; Read next file track
;
; Entry:
;
; toc_entry - as initialised by file_read_init, or as updated by last
; call to file_read_next_track
;
; read_byte_addr - where to write the data to. Up to 4 KB of data will
; be read
;
; Exit:
;
; toc_entry - updated for next read
;
; read_byte_counter - negative count of bytes read
;
; C=0 if end of file reached

file_read_next_track: .block
                ; 0-byte files are not supposed to be a thing, but it
                ; simplifies the compressed file loading to handle
                ; this case.
                lda toc_entry.negative_size+0
                ora toc_entry.negative_size+1
                beq done        ; exit with C=0 indicating EOF
                
                ; fill out the byte count for the read.
                jsr get_read_byte_counter

                ; seek to the track.
                lda toc_entry.ltrack
                jsr seek

                ; do the read.
                lda toc_entry.sector_and_flags
                and #$0f
                jsr read

                ; get the read counter again.
                jsr get_read_byte_counter

                ; prepare for next read. bump the track counter.
                ; always start from sector 0 on subsequent tracks.
                inc toc_entry.ltrack

                lda toc_entry.sector_and_flags
                and #$f0
                sta toc_entry.sector_and_flags

                ; bump bytes left by quantity read.
                sec
                lda toc_entry.negative_size+0
                sbc read_byte_counter+0
                sta toc_entry.negative_size+0
                lda toc_entry.negative_size+1
                sbc read_byte_counter+1
                sta toc_entry.negative_size+1

done:
                cmp #1

                rts

get_read_byte_counter:
                lda toc_entry.negative_size+1
                cmp #$f0

                ; MSB of negative amount of data left in sector.
                ; -4096=$f000, -256=$ff00 - the constant can be
                ; -generated from the sector number.
                lda toc_entry.sector_and_flags
                ora #$f0
                
                bcs in_last_4KB ; taken if <=4096 bytes left in file

read_remainder_of_track:
                ; read as much as is left on the track given the start
                ; sector - max 4096 bytes.
                sta read_byte_counter+1
                stz read_byte_counter+0
                rts

in_last_4KB:
                cmp toc_entry.negative_size+1
                beq +
                bcs read_remainder_of_track
+
                ; what's left on the track covers what's left of the
                ; file, so read all of it.
                lda toc_entry.negative_size+0
                sta read_byte_counter+0
                lda toc_entry.negative_size+1
                sta read_byte_counter+1
                rts

                .endblock

;--------------------------------------------------
;
; Decompress ZX0 data (6502 optimized format) - slightly butchered
; version of zx02-small.asm. 
;
; on entry, caller must have filled in:
;
; ZX0_src - where to read compressed data from
;
; ZX0_dst - where to write uncompressed data to
;
; ZX0_resume_state - set bit 7 if decomppression should be resumable. if
; ZX0_src MSB hits ZX0_src_buf_end_page, the call will return, ready to
; run again from where it left off with the next lump of data.
; (Reinitialise ZX0_src to point to the start of the buffer again.)
;
; on exit:
;
; ZX0_resume_state - if bit 7 was set on entry: bit 7 is clear if
; decompression complete, or set if still more data required.
;
; initial offset is (for now) always 0.

full_decomp: .block
                tsx
                stx entry_s

                lda ZX0_resume_state
                cmp #%11000000
                ; taken if bit 7 (resumable) and bit 6 (resume state)
                bcs get_src_byte.resume 
                
                lda #$80
                sta bitr

                stz offset+0
                stz offset+1
                
                ; Decode literal: Copy next N bytes from compressed file
                ;    Elias(length)  byte[1]  byte[2]  ...  byte[N]
decode_literal:
                ldx   #1
                jsr   get_elias

                clc             ; copy from src
                jsr copy_bytes
                bcs   dzx0s_new_offset

                ; Copy from last offset (repeat N bytes from last offset)
                ;    Elias(length)
                inx
                jsr   get_elias
dzx0s_copy:
; C=0 from get_elias

                lda ZX0_dst+0
                sbc offset+0
                sta pntr+0

                lda ZX0_dst+1
                sbc offset+1
                sta pntr+1

                ; TODO - will C always be set from the pointer
                ; adjustment?
                sec             ; copy from pntr
                jsr copy_bytes

                bcc   decode_literal

                ; Copy from new offset (repeat N bytes from new offset)
                ;    Elias(MSB(offset))  LSB(offset)  Elias(length-1)
dzx0s_new_offset:
; Read elias code for high part of offset
                inx
                jsr   get_elias
                beq   exit  ; Read a 0, signals the end
                ; Decrease and divide by 2
                dex
                txa
                lsr   a
                sta   offset+1

                ; Get low part of offset, a literal 7 bits
                jsr   get_src_byte

                ; Divide by 2
                ror   a
                sta   offset

                ; And get the copy length.
                ; Start elias reading with the bit already in carry:
                ldx   #1
                jsr   elias_skip1

                inx
                bcc   dzx0s_copy

; Read an elias-gamma interlaced code.
; ------------------------------------
elias_loop:
; Read next data bit to result
                asl   bitr
                rol   a
                tax

get_elias:
; Get one bit
                asl   bitr
                bne   elias_skip1

                ; Read new bit from stream
                jsr   get_src_byte
                ;sec   ; not needed, C=1 guaranteed from last bit
                rol   a
                sta   bitr

elias_skip1:
                txa
                bcs   elias_loop
                ; Got ending bit, stop reading with C=0
                rts

;-------------------------------------------------------------------------

; hit end of data. indicate no resume.
exit:
                lsr ZX0_resume_state
                rts
                
;-------------------------------------------------------------------------

; must preserve X/Y/C
get_src_byte: .block
                lda (ZX0_src)
                inc ZX0_src+0
                bne done
                inc ZX0_src+1
                bit ZX0_resume_state
                bpl done              ; not resumable
                pha                   ; save byte read
                lda ZX0_src+1         ; src address MSB
                eor ZX0_src_buf_end_page  ; compare to end address MSB
                bne got_addr          ; taken if not at end of buffer

                php             ; save C
                phx             ; save X
                phy             ; save Y

                ldy #0
save_stack_loop:
                pla
                sta stack_buf,y
                iny
                tsx
                cpx entry_s
                bne save_stack_loop
                sty stack_buf_size

                ; set bits 6+7 - resumable, and resume state present.
                sec
                ror ZX0_resume_state ; set bit 6 - state saved.
                rts              ; return to caller
resume:
                ldy stack_buf_size
restore_stack_loop:
                lda stack_buf-1,y
                pha
                dey
                bne restore_stack_loop

                ; ; indicate operation still resumable, but resume data
                ; ; no longer present.
                ; lda #$40
                ; trb ZX0_resume_state

                ply
                plx
                plp
got_addr:
                pla
done:
                rts
                .endblock

copy_bytes: .block
                ldy #0
loop:
                ; slightly prioritize throughput for copying from
                ; pntr. this is where the compression comes from so
                ; hopefully it'll be the commoner case.
                bcs pntr_byte
src_byte:
                jsr get_src_byte
                bra got_byte
pntr_byte:
                lda (pntr)
                inc pntr+0
                bne +
                inc pntr+1
+
got_byte:
                sta (ZX0_dst),y
                iny
                dex
                bne loop
                tya
                clc
                beq carry ; taken if X was 0 on entry - 256 bytes were
                          ; copied
                adc ZX0_dst+0
                sta ZX0_dst+0
                bcc +
carry:
                inc ZX0_dst+1
+
                asl bitr
                rts
                .endblock
                .endblock

working_code_end:
                .endsection fdload_working_code

                .endblock

                