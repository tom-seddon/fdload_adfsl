                .include "../submodules/beeb/include/beeb.s65"
                .include "demo_shared_constants.s65"

;-------------------------------------------------------------------------

; if set, show timing using palette switches.
visible_timing=true

;-------------------------------------------------------------------------

*=$00
                .dsection zp
                .cerror *>reserved_zp_begin

;-------------------------------------------------------------------------

*=$300
                .dsection workspace
                .cerror *>demo_scroller1_begin
                
;-------------------------------------------------------------------------

*=demo_scroller1_begin
                .dsection code
                .align 8
                .dsection display_buffers
                .cerror *>demo_scroller1_end

;-------------------------------------------------------------------------

mode2_palette_entry: .function _logical,_physical
                .cerror !((_logical)>=0&&(_logical)<16)
                .cerror !((_physical)>=0&&(_physical)<16)
                .endfunction ((_logical)<<4)|((_physical)^7)

;-------------------------------------------------------------------------

                .section zp
glyph_ptr: .fill 2
last_glyph_ptr: .fill 2
glyph_column: .fill 1
text_ptr: .fill 2
dynamic_glyph_column_ptr: .fill 2
glyph_column_counter: .fill 1
num_frames: .fill 1
glyph_ptrs_offset: .fill 1
column_glyph_ptr: .fill 2
num_vsyncs: .fill 1
y_offset_ptr: .fill 2
                .endsection zp

;-------------------------------------------------------------------------

num_columns=48
glyph_width_columns=4
glyph_height=16
glyph_column_size=2*glyph_height
char_row_height=4
display_buffer_size=num_columns*8*(glyph_height/char_row_height)
                
                .section workspace
column_glyph_ptrs_lsb:
                .fill 2*num_columns ; frame 0 LSBs
                .fill 2*num_columns ; frame 1 LSBs
                .cerror *-column_glyph_ptrs_lsb>=256
column_glyph_ptrs_msb:
                .fill 2*num_columns ; frame 0 MSBs
                .fill 2*num_columns ; frame 1 MSBs

num_dynamic_glyph_columns=num_columns/glyph_width_columns+1
dynamic_glyph_columns: .fill num_dynamic_glyph_columns*glyph_column_size
dynamic_glyph_columns_end:
                .endsection

                .section display_buffers
display_buffers: .block
a: .fill display_buffer_size
b: .fill display_buffer_size
c: .fill display_buffer_size
                .endblock
                .endsection

;-------------------------------------------------------------------------

                .section code
start:
                ldx #13
init_crtc_loop:
                stx $fe00
                lda mode5_crtc,x
                sta $fe01
                dex
                bpl init_crtc_loop
                
                ldx #15
init_palette_loop:
                lda mode2_palette,x
                sta video_ula_palette
                dex
                bpl init_palette_loop

                ldx #0
clear_memory_loop:
clear_memory_store: stz $5800,x
                inx
                bne clear_memory_loop
                inc clear_memory_store+2
                bpl clear_memory_loop

                stz video_ula_control ; Mode 8

                lda #$80|VIAIRQ.ca1
                sta system_via.ier

                ldx #<handle_irq
                ldy #>handle_irq
                jsr irq_copy_handler

                ldx #0
init_zp_loop:
                stz 0,x
                inx
                cpx #reserved_zp_begin
                bne init_zp_loop

                ldx #2*2*num_columns
init_column_glyph_ptrs_loop:
                lda #<char_blank_column
                sta column_glyph_ptrs_lsb-1,x
                sta last_glyph_ptr+0
                lda #>char_blank_column
                sta column_glyph_ptrs_msb-1,x
                sta last_glyph_ptr+1
                dex
                bne init_column_glyph_ptrs_loop

                jsr reset_text_ptr

                jsr reset_dynamic_glyph_column_ptr

                jsr reset_y_offset_ptr

loop_one_char:
                jsr fetch_glyph_ptr

                ; (last_glyph_ptr) points to the last column.
                ldy #31
merge_columns_loop:
                lda (last_glyph_ptr),y ; left pixel
                ora (glyph_ptr),y      ; right pixel
                sta (dynamic_glyph_column_ptr),y
                dey
                bpl merge_columns_loop

                ldx #dynamic_glyph_column_ptr
                jsr scroll

                lda #7
                sta glyph_column_counter

                ; enter mid-loop. don't draw column 0 shifted. do
                ; increment again after drawing columns 6+7 unshifted,
                ; so that glyph_ptr points to column 7 shifted for
                ; merging into the next glyph.
                bra next_glyph_ptr
                
scroll_loop:
                ldx #glyph_ptr
                jsr scroll
next_glyph_ptr:
                lda glyph_ptr+0
                clc
                adc #glyph_column_size
                sta glyph_ptr+0
                bcc +
                inc glyph_ptr+1
+

                dec glyph_column_counter
                bpl scroll_loop

                ; save pointer to column N-1 shifted.
                lda glyph_ptr+0
                sta last_glyph_ptr+0
                lda glyph_ptr+1
                sta last_glyph_ptr+1

                clc
                lda dynamic_glyph_column_ptr+0
                adc #glyph_column_size
                sta dynamic_glyph_column_ptr+0
                bcc +
                inc dynamic_glyph_column_ptr+1
+
                cmp #<dynamic_glyph_columns_end
                bne got_dynamic_glyph_column
                lda dynamic_glyph_column_ptr+1
                cmp #>dynamic_glyph_columns_end
                bne got_dynamic_glyph_column

                jsr reset_dynamic_glyph_column_ptr
                
got_dynamic_glyph_column:
                jmp loop_one_char

;-------------------------------------------------------------------------

scroll_unroll: .macro debug,dest

                .for column in range(num_columns)
                lda column_glyph_ptrs_lsb,x ; LSB
                sta column_glyph_ptr+0
                lda column_glyph_ptrs_msb,x
                sta column_glyph_ptr+1

                ldy #column
                lda (y_offset_ptr),y
                tay

                inx

                .for row in range(16)
                lda (column_glyph_ptr),y
                iny
                .if \debug
dest:=\dest
dest+=column%40*8
dest+=column/40*640
dest+=row/8*320
dest+=row%8
                sta dest
                .else
dest:=\dest
dest+=column*8
dest+=row/4*320
dest+=row%4
                .error
                .endif
                .endfor
                .endfor
                
                
                .endmacro
                
scroll:
                phx             ; save initial offset
                
                ; select frame0 or frame1 tables.
                lda num_frames
                and #1
                beq +                ; taken if frame0 table
                lda #2*num_columns ; select frame1 table
+

                ; apply offset.
                clc
                adc glyph_ptrs_offset
                pha             ; save column_glyph_ptrs offset

                tax

                .scroll_unroll true,$6700
                
                ; .for column in range(num_columns)
                ; lda column_glyph_ptrs_lsb,x ; LSB
                ; sta column_glyph_ptr+0
                ; lda column_glyph_ptrs_msb,x
                ; sta column_glyph_ptr+1
                ; inx

                ; ; txa
                ; ; and #15
                ; ; tay
                ; ldy #0

                ; .for row in range(16)
                ; lda (column_glyph_ptr),y
                ; iny
                ; sta $6700+(column%40)*8+(column/40)*640+(row/8)*320+(row%8)
                ; .endfor
                ; .endfor

                .if visible_timing
                lda #mode2_palette_entry(0,0)
                sta video_ula_palette
                .endif

                ldy #1
wait_for_n_vsyncs_loop:
                lda num_vsyncs
wait_for_vsync_loop:
                ; do memory refresh while waiting. initial X value
                ; doesn't matter... it'll visit all of them
                ; eventually.
                bit 0,x
                inx
                cmp num_vsyncs
                beq wait_for_vsync_loop
                dey
                bne wait_for_n_vsyncs_loop

                .if visible_timing
                lda #mode2_palette_entry(0,2)
                sta video_ula_palette
                .endif

                ply             ; restore column_glyph_ptrs offset
                plx             ; restore initial offset
                
                ; store LSBs
                lda 0,x
                sta column_glyph_ptrs_lsb+0,y
                sta column_glyph_ptrs_lsb+num_columns,y

                ; store MSBs
                lda 1,x
                sta column_glyph_ptrs_msb+0,y
                sta column_glyph_ptrs_msb+num_columns,y

                ; advance offset?
                lda num_frames
                and #1
                beq got_glyph_ptrs_offset

                ; advance offset.
                lda glyph_ptrs_offset
                inc a
                cmp #num_columns
                bcc +
                lda #0
+
                sta glyph_ptrs_offset

                jsr next_y_offset_ptr

got_glyph_ptrs_offset:

                inc num_frames

                rts
                
;-------------------------------------------------------------------------

reset_dynamic_glyph_column_ptr:
                lda #<dynamic_glyph_columns
                sta dynamic_glyph_column_ptr+0
                lda #>dynamic_glyph_columns
                sta dynamic_glyph_column_ptr+1

                rts

;-------------------------------------------------------------------------

next_y_offset_ptr: .block
y_sines_end=y_sines+y_sines_size
                
                inc y_offset_ptr+0
                bne +
                inc y_offset_ptr+1
+
                lda y_offset_ptr+0
                cmp #<y_sines_end
                bne reset_y_offset_ptr.done
                lda y_offset_ptr+1
                cmp #>y_sines_end
                bne reset_y_offset_ptr.done
                .cerror *!=reset_y_offset_ptr
                .endblock
reset_y_offset_ptr: .block
                lda #<y_sines
                sta y_offset_ptr+0
                lda #>y_sines
                sta y_offset_ptr+1
done:
                rts
                .endblock
                
;-------------------------------------------------------------------------

; fetch pointer to next glyph. update text_ptr as required.
;
; preserves: X
fetch_glyph_ptr:
                lda (text_ptr)
                sta glyph_ptr+0
                ldy #1
                lda (text_ptr),y
                sta glyph_ptr+1

                ; post increment
                clc
                lda text_ptr+0
                adc #2
                sta text_ptr+0
                bcc got_text_ptr
                inc text_ptr+1
got_text_ptr:
                lda (text_ptr)
                ora (text_ptr),y
                bne done
reset_text_ptr:
                lda #<scroll_text
                sta text_ptr+0
                lda #>scroll_text
                sta text_ptr+1
done:
                rts

;-------------------------------------------------------------------------

handle_irq:
                lda system_via.ifr
                bpl +
                sta system_via.ifr
                bit #VIAIRQ.ca1
                beq +
                inc num_vsyncs
+
                lda $fc
                rti
                
;-------------------------------------------------------------------------

mode5_crtc:
                ;     R0  R1  R2  R3  R4  R5  R6  R7
                .byte $3f,$28,$31,$24,$26,$00,$20,$22
                ;     R8  R9  R10 R11
                .byte $00,$07,$67,$08
                .byte >($5800>>3) ; R12
                .byte <($5800>>3) ; R13
                
;-------------------------------------------------------------------------

mode2_palette:
                .for _i:=0,_i<16,_i+=1
                .byte mode2_palette_entry(_i,_i&7)
                .endfor

;-------------------------------------------------------------------------

                .include "../build/dist_scroller.text.generated.s65"
                .include "../build/dist_scroller.glyphs.generated.s65"

;-------------------------------------------------------------------------

y_sines_size=300
y_sines:
                .bfor i in range(y_sines_size+num_columns)
theta=float(i)/y_sines_size*2*pi
                .byte floor(16+sin(theta)*16)%16
                .endfor
                
;-------------------------------------------------------------------------

                .endsection code