                .include "../submodules/beeb/include/beeb.s65"
                .include "demo_shared_constants.s65"

;-------------------------------------------------------------------------

; if true, show timing using palette switches.
visible_timing=true

; if true, just have ordinary display with no funny business.
ordinary_display=false
                
;-------------------------------------------------------------------------

*=$00
                .dsection zp
                .cerror *>reserved_zp_begin

;-------------------------------------------------------------------------

*=$300
                .dsection workspace
                .cerror *>demo_scroller1_begin
                
;-------------------------------------------------------------------------

*=demo_scroller1_begin
                .dsection code
                .align 8*8
                .dsection display_buffers
                .cerror *>$8000
                .dsection unrolls
                .cerror *>demo_scroller1_end

;-------------------------------------------------------------------------

mode2_palette_entry: .function _logical,_physical
                .cerror !((_logical)>=0&&(_logical)<16)
                .cerror !((_physical)>=0&&(_physical)<16)
                .endfunction ((_logical)<<4)|((_physical)^7)

;-------------------------------------------------------------------------

                .section zp
glyph_ptr: .fill 2
last_glyph_ptr: .fill 2
glyph_column: .fill 1
text_ptr: .fill 2
dynamic_glyph_column_ptr: .fill 2
glyph_column_counter: .fill 1
num_frames: .fill 1
glyph_ptrs_offset: .fill 1
column_glyph_ptr: .fill 2
num_vsyncs: .fill 1
y_offset_ptr: .fill 2
display_buffer_0_index: .fill 1
display_buffer_1_index: .fill 1
write_buffer_index: .fill 1
x_offset_ptr: .fill 2

                ; IRQ handler stuff
irq_region: .fill 1
irq_crtc_base: .fill 2
                .endsection zp


;-------------------------------------------------------------------------

; Display setup.
                
; 8 scanlines = "row"
; 4 scanlines = "half row"
;
; these units are stupid, but it simplifies the calculations a little
; bit.
                
initial_t1_value=40*64-128
t1_value_1_half_row=1*4*64-2
num_visible_rows=20
vsync_row=34
total_num_rows=39
t1_value_8_rows=(total_num_rows-(num_visible_rows-1))*8*64-2
                .cerror t1_value_8_rows>=65536
                
;-------------------------------------------------------------------------

; Display buffer setup.
                
num_columns=48
glyph_width_columns=4
glyph_height=16
glyph_column_size=2*glyph_height
char_row_height=4
display_buffer_size=num_columns*8*(glyph_height/char_row_height)
                
                .section workspace
column_glyph_ptrs_lsb:
                .fill 2*num_columns ; frame 0 LSBs
                .fill 2*num_columns ; frame 1 LSBs
                .cerror *-column_glyph_ptrs_lsb>=256
column_glyph_ptrs_msb:
                .fill 2*num_columns ; frame 0 MSBs
                .fill 2*num_columns ; frame 1 MSBs

num_dynamic_glyph_columns=num_columns/glyph_width_columns+1
dynamic_glyph_columns: .fill num_dynamic_glyph_columns*glyph_column_size
dynamic_glyph_columns_end:
                .endsection

                .section display_buffers
                ; ensure bottom 3 bits of CRTC address will be 0.
                .cerror display_buffer_size%(8*8)!=0
                .cerror *%(8*8)!=0
display_buffers: .block
a: .fill display_buffer_size
b: .fill display_buffer_size
c: .fill display_buffer_size
                .endblock
                .endsection

;-------------------------------------------------------------------------

                .section code
start:
                jsr init

loop_one_char:
                jsr fetch_glyph_ptr

                ; (last_glyph_ptr) points to the last column.
                ldy #31
merge_columns_loop:
                lda (last_glyph_ptr),y ; left pixel
                ora (glyph_ptr),y      ; right pixel
                sta (dynamic_glyph_column_ptr),y
                dey
                bpl merge_columns_loop

                ldx #dynamic_glyph_column_ptr
                jsr scroll

                lda #7
                sta glyph_column_counter

                ; enter mid-loop. don't draw column 0 shifted. do
                ; increment again after drawing columns 6+7 unshifted,
                ; so that glyph_ptr points to column 7 shifted for
                ; merging into the next glyph.
                bra next_glyph_ptr
                
scroll_loop:
                ldx #glyph_ptr
                jsr scroll
next_glyph_ptr:
                lda glyph_ptr+0
                clc
                adc #glyph_column_size
                sta glyph_ptr+0
                bcc +
                inc glyph_ptr+1
+

                dec glyph_column_counter
                bpl scroll_loop

                ; save pointer to column N-1 shifted.
                lda glyph_ptr+0
                sta last_glyph_ptr+0
                lda glyph_ptr+1
                sta last_glyph_ptr+1

                clc
                lda dynamic_glyph_column_ptr+0
                adc #glyph_column_size
                sta dynamic_glyph_column_ptr+0
                bcc +
                inc dynamic_glyph_column_ptr+1
+
                cmp #<dynamic_glyph_columns_end
                bne got_dynamic_glyph_column
                lda dynamic_glyph_column_ptr+1
                cmp #>dynamic_glyph_columns_end
                bne got_dynamic_glyph_column

                jsr reset_dynamic_glyph_column_ptr
                
got_dynamic_glyph_column:
                jmp loop_one_char

;-------------------------------------------------------------------------

init: .block
                ; Initialise CRTC.
                ldx #13
init_crtc_loop:
                stx $fe00
                lda mode5_crtc,x
                sta $fe01
                dex
                bpl init_crtc_loop

                ; Initialise palette.
                ldx #15
init_palette_loop:
                lda mode2_palette,x
                sta video_ula_palette
                dex
                bpl init_palette_loop

                ; Select Mode 8.
                stz video_ula_control

                .if ordinary_display
                ; Clear memory.
                ldx #0
clear_memory_loop:
clear_memory_store: stz $5800,x
                inx
                bne clear_memory_loop
                inc clear_memory_store+2
                bpl clear_memory_loop
                .endif

                ldx #0
init_zp_loop:
                stz 0,x
                inx
                cpx #reserved_zp_begin
                bne init_zp_loop

                lda #buffer_infos.a-buffer_infos
                sta display_buffer_0_index
                lda #buffer_infos.b-buffer_infos
                sta display_buffer_1_index
                lda #buffer_infos.c-buffer_infos
                sta write_buffer_index

                jsr update_irq_crtc_base
               
                ; Initialise glyph pointers table.
                ldx #2*2*num_columns
init_column_glyph_ptrs_loop:
                lda #<char_blank_column
                sta column_glyph_ptrs_lsb-1,x
                sta last_glyph_ptr+0
                lda #>char_blank_column
                sta column_glyph_ptrs_msb-1,x
                sta last_glyph_ptr+1
                dex
                bne init_column_glyph_ptrs_loop

                ; Reset pointers.
                jsr reset_text_ptr
                jsr reset_dynamic_glyph_column_ptr
                jsr reset_y_offset_ptr
                jsr reset_x_offset_ptr

                ; Set up system VIA.

                ldx #<handle_irq
                ldy #>handle_irq
                jsr irq_set_handler

                .if ordinary_display

                ; enable vsync IRQ only.
                lda #$80|VIAIRQ.ca1
                sta system_via.ier

                .else

                lda #%01000000 ; VIA ACR - T1 continuous, T2 one-shot
                sta system_via.acr

                ; Vertical displayed=1
                lda #6
                sta $fe00
                lda #1
                sta $fe01

                ; wait for vsync at scanline 274 or so.
                lda #VIAIRQ.ca1
                sta system_via.ifr
wait_for_vsync_loop:
                bit system_via.ifr
                beq wait_for_vsync_loop

                ; request IRQ at some point in row 0
                lda #<initial_t1_value
                sta system_via.t1l_l
                lda #>initial_t1_value
                sta system_via.t1c_h

                ; enable timer IRQ.
                lda #$80|VIAIRQ.t1
                sta system_via.ier

                ; Set up the latch for the subsequent timeout.
                lda #<t1_value_1_half_row
                sta system_via.t1l_l
                lda #>t1_value_1_half_row
                sta system_via.t1l_h
                
                ; Set up CRTC vsync row
                lda #7
                sta $fe00
                lda #vsync_row-num_visible_rows
                sta $fe01

                .endif

                rts
                .endblock

;-------------------------------------------------------------------------

                .if ordinary_display
                
handle_irq: .block
                lda system_via.ifr
                bpl +
                sta system_via.ifr
                bit #VIAIRQ.ca1
                beq +
                inc num_vsyncs
+
                lda $fc
                rti
                .endblock

                .else
                
handle_irq: .block
                ; there's only one source of IRQs here.
                lda system_via.ifr
                sta system_via.ifr ; acknowledge all

                lda irq_region
                beq handle_first_prepare_second
                cmp #num_visible_rows*2-2
                beq handle_penultimate_prepare_last
                cmp #num_visible_rows*2-1
                beq handle_last_prepare_first

done:
prepare_nth:
                stx reldx+1
                sty reldy+1

                ldy irq_region
                iny
                sty irq_region

                lda #13
                sta $fe00
                
                lda (x_offset_ptr),y
                lsr a           ; A=X offset; C=buffer index
                ldx display_buffer_0_index
                bcc +
                ldx display_buffer_1_index
+
                clc
                adc buffer_infos+BufferInfo.crtc_address+0,x ; no carry
                adc crtc_row_offsets,y ; possible carry
                sta $fe01

                lda #12
                sta $fe00
                lda #0
                adc buffer_infos+BufferInfo.crtc_address+1,x
                sta $fe01
                
                ; lda #13
                ; sta $fe00
                ; clc
                ; lda irq_crtc_base+0
                ; adc crtc_row_offsets,
                ; sta $fe01
                
                ; lda #12
                ; sta $fe00
                ; lda #0
                ; adc irq_crtc_base+1
                ; sta $fe01

reldx: ldx #$ff
reldy: ldy #$ff
                lda $fc
                rti                

handle_first_prepare_second:
                ; Scanlines per row=4
                lda #9
                sta $fe00
                lda #3
                sta $fe01

                ; Vertical total=1
                lda #4
                sta $fe00
                stz $fe01
                bra done

handle_last_prepare_first:
                lda #<t1_value_1_half_row
                sta system_via.t1l_l
                lda #>t1_value_1_half_row
                sta system_via.t1l_h

                ; Scanlines per row=8
                lda #9
                sta $fe00
                lda #7
                sta $fe01

                ; Vertical total=N
                lda #4
                sta $fe00
                lda #total_num_rows-num_visible_rows
                sta $fe01

                ; the inc is inevitable, so ensure the value ends up
                ; $00.
                lda #$ff
                sta irq_region

                ; not actually the vsync, but it's close enough to
                ; count.
                inc num_vsyncs
                
                bra done

handle_penultimate_prepare_last:
                lda #<t1_value_8_rows
                sta system_via.t1l_l
                lda #>t1_value_8_rows
                sta system_via.t1l_h

                bra done
                
                .endblock
                .endif
                
                ;.cerror size(handle_irq)>size(irq_handler_space)
                
;-------------------------------------------------------------------------

scroll_unroll: .macro debug,dest

                .for column in range(num_columns)
                lda column_glyph_ptrs_lsb,x ; LSB
                sta column_glyph_ptr+0
                lda column_glyph_ptrs_msb,x
                sta column_glyph_ptr+1

                ldy #column
                lda (y_offset_ptr),y
                tay

                inx

                .for row in range(16)
                lda (column_glyph_ptr),y
                iny
                .if \debug
dest:=\dest
dest+=column%40*8
dest+=column/40*640
dest+=row/8*320
dest+=row%8
                sta dest
                .else
dest:=\dest
dest+=column*8
dest+=row/4*(num_columns*8)
dest+=row%4
                sta dest
                .endif
                .endfor
                .endfor
                
                
                .endmacro
                
scroll: .block
                phx             ; save initial offset
                
                ; select frame0 or frame1 tables.
                lda num_frames
                and #1
                beq +                ; taken if frame0 table
                lda #2*num_columns ; select frame1 table
+

                ; apply offset.
                clc
                adc glyph_ptrs_offset
                pha             ; save column_glyph_ptrs offset


                .if ordinary_display
                
                tax
                .scroll_unroll true,$6700

                .else

                ldx write_buffer_index
                jsr jmp_unroll
                ; .scroll_unroll false,display_buffers.a

                .endif
                
                ; .for column in range(num_columns)
                ; lda column_glyph_ptrs_lsb,x ; LSB
                ; sta column_glyph_ptr+0
                ; lda column_glyph_ptrs_msb,x
                ; sta column_glyph_ptr+1
                ; inx

                ; ; txa
                ; ; and #15
                ; ; tay
                ; ldy #0

                ; .for row in range(16)
                ; lda (column_glyph_ptr),y
                ; iny
                ; sta $6700+(column%40)*8+(column/40)*640+(row/8)*320+(row%8)
                ; .endfor
                ; .endfor

                .if visible_timing
                lda #mode2_palette_entry(0,0)
                sta video_ula_palette
                .endif

                ldy #1
wait_for_n_vsyncs_loop:
                lda num_vsyncs
wait_for_vsync_loop:
                ; do memory refresh while waiting. initial X value
                ; doesn't matter... it'll visit all of them
                ; eventually.
                bit 0,x
                inx
                cmp num_vsyncs
                beq wait_for_vsync_loop
                dey
                bne wait_for_n_vsyncs_loop

                .if visible_timing
                lda #mode2_palette_entry(0,2)
                sta video_ula_palette
                .endif

                ply             ; restore column_glyph_ptrs offset
                plx             ; restore initial offset
                
                ; store LSBs
                lda 0,x
                sta column_glyph_ptrs_lsb+0,y
                sta column_glyph_ptrs_lsb+num_columns,y

                ; store MSBs
                lda 1,x
                sta column_glyph_ptrs_msb+0,y
                sta column_glyph_ptrs_msb+num_columns,y

                ; advance offset?
                lda num_frames
                and #1
                beq got_glyph_ptrs_offset

                ; advance offset.
                lda glyph_ptrs_offset
                inc a
                cmp #num_columns
                bcc +
                lda #0
+
                sta glyph_ptrs_offset

                jsr next_y_offset_ptr
                jsr next_y_offset_ptr

                jsr next_x_offset_ptr

got_glyph_ptrs_offset:

                inc num_frames

                ldx write_buffer_index

                lda display_buffer_0_index
                sta write_buffer_index

                lda display_buffer_1_index
                sta display_buffer_0_index

                stx display_buffer_1_index

                ; TODO - this is too late! The updated value needs to
                ; be available in time for handle_last_prepare_first,
                ; but that has already happened at this point. It was
                ; what wait_for_vsync_loop above was waiting for.
                jsr update_irq_crtc_base

                rts

jmp_unroll:
                jmp (buffer_infos+BufferInfo.fill_routine,x)
                .endblock

;-------------------------------------------------------------------------

update_irq_crtc_base:
                ldx display_buffer_0_index

                lda buffer_infos+BufferInfo.crtc_address+0,x
                sta irq_crtc_base+0
                lda buffer_infos+BufferInfo.crtc_address+1,x
                sta irq_crtc_base+1

                rts
                
;-------------------------------------------------------------------------

reset_dynamic_glyph_column_ptr:
                lda #<dynamic_glyph_columns
                sta dynamic_glyph_column_ptr+0
                lda #>dynamic_glyph_columns
                sta dynamic_glyph_column_ptr+1

                rts

;-------------------------------------------------------------------------

next_x_offset_ptr: .block
x_sines_end=x_sines+x_sines_size

                inc x_offset_ptr+0
                bne +
                inc x_offset_ptr+1
+
                lda x_offset_ptr+0
                cmp #<x_sines_end
                bne reset_x_offset_ptr.done
                lda x_offset_ptr+1
                cmp #>x_sines_end
                bne reset_x_offset_ptr.done
                .cerror *!=reset_x_offset_ptr
                .endblock
reset_x_offset_ptr: .block
                lda #<x_sines
                sta x_offset_ptr+0
                lda #>x_sines
                sta x_offset_ptr+1
done:
                rts
                .endblock
                
next_y_offset_ptr: .block
y_sines_end=y_sines+y_sines_size
                
                inc y_offset_ptr+0
                bne +
                inc y_offset_ptr+1
+
                lda y_offset_ptr+0
                cmp #<y_sines_end
                bne reset_y_offset_ptr.done
                lda y_offset_ptr+1
                cmp #>y_sines_end
                bne reset_y_offset_ptr.done
                .cerror *!=reset_y_offset_ptr
                .endblock
reset_y_offset_ptr: .block
                lda #<y_sines
                sta y_offset_ptr+0
                lda #>y_sines
                sta y_offset_ptr+1
done:
                rts
                .endblock
                
;-------------------------------------------------------------------------

; fetch pointer to next glyph. update text_ptr as required.
;
; preserves: X
fetch_glyph_ptr: .block
                lda (text_ptr)
                sta glyph_ptr+0
                ldy #1
                lda (text_ptr),y
                sta glyph_ptr+1

                ; post increment
                clc
                lda text_ptr+0
                adc #2
                sta text_ptr+0
                bcc got_text_ptr
                inc text_ptr+1
got_text_ptr:
                lda (text_ptr)
                ora (text_ptr),y
                bne reset_text_ptr.done
                .cerror *!=reset_text_ptr
                .endblock
reset_text_ptr: .block
                lda #<scroll_text
                sta text_ptr+0
                lda #>scroll_text
                sta text_ptr+1
done:
                rts
                .endblock

;-------------------------------------------------------------------------

mode5_crtc:
                ;     R0  R1  R2  R3  R4  R5  R6  R7
                .byte $3f,$28,$31,$24,$26,$00,$20,$22
                ;     R8  R9  R10 R11
                .byte $00,$07,$67,$08
                .if ordinary_display
                .byte >($5800>>3) ; R12
                .byte <($5800>>3) ; R13
                .else
                .byte >(display_buffers.a>>3)
                .byte <(display_buffers.a>>3)
                .endif
                
;-------------------------------------------------------------------------

mode2_palette:
                .for _i:=0,_i<16,_i+=1
                .byte mode2_palette_entry(_i,_i&7)
                .endfor

;-------------------------------------------------------------------------

                .include "../build/dist_scroller.text.generated.s65"
                .include "../build/dist_scroller.glyphs.generated.s65"

;-------------------------------------------------------------------------

y_sines_size=100
y_sines:
                .bfor i in range(y_sines_size+num_columns)
theta=float(i)/y_sines_size*2*pi
                .byte floor(16+sin(theta)*16)%16
                .endfor

;-------------------------------------------------------------------------

x_sines_size=101
x_sines:
                .bfor i in range(x_sines_size+num_visible_rows*2)
theta=float(i)/x_sines_size*2*pi
x_=8+floor(sin(theta)*8)
                .byte x_
                .endfor

;-------------------------------------------------------------------------

crtc_row_offsets:
                .bfor i in range(num_visible_rows*2)
                .byte (i%4)*48
                .endfor

;-------------------------------------------------------------------------

BufferInfo: .struct _address,_fill_routine
address: .word (\_address)
crtc_address: .word (\_address)>>3
fill_routine: .word (\_fill_routine)
                .endstruct
                
; buffer_info: .macro address,fill_routine
;                 .dstruct BufferInfo,(\address),(\address)>>3,(\fill_routine)
;                 .endmacro
                
buffer_infos: .block
a: .dstruct BufferInfo,display_buffers.a,fill_buffer_a
b: .dstruct BufferInfo,display_buffers.b,fill_buffer_b
c: .dstruct BufferInfo,display_buffers.c,fill_buffer_c
                .endblock
                
;-------------------------------------------------------------------------

                .endsection code

;-------------------------------------------------------------------------

                .section unrolls

fill_buffer_a:
                tax
                .scroll_unroll false,display_buffers.a
                rts

fill_buffer_b:
                tax
                .scroll_unroll false,display_buffers.b
                rts

fill_buffer_c:
                tax
                .scroll_unroll false,display_buffers.c
                rts
                
                .endsection unrolls